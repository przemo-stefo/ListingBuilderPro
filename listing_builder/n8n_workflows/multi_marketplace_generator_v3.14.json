{
  "updatedAt": "2026-02-03T18:47:19.569Z",
  "createdAt": "2026-01-16T14:12:43.404Z",
  "id": "DkudCZWTD4TI1FRE",
  "name": "Multi Marketplace Listing Generator",
  "description": null,
  "active": true,
  "isArchived": false,
  "nodes": [
    {
      "id": "webhook",
      "name": "Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        0,
        0
      ],
      "parameters": {
        "path": "v2/product",
        "httpMethod": "POST",
        "responseMode": "lastNode",
        "options": {
          "responseCode": 200
        }
      },
      "webhookId": "v2-product"
    },
    {
      "id": "process-input",
      "name": "Process Input",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        200,
        0
      ],
      "parameters": {
        "jsCode": "// Process Input v2.1 - Auth + Keyword File + Validation\n// ADDED: Marketplace whitelist, prompt injection sanitization\n// Updated: 2026-02-03\nconst input = $input.first().json;\n\n// === AUTHENTICATION ===\nconst WEBHOOK_API_KEY = 'WEBHOOK_API_KEY_REDACTED';\nconst providedKey = input.headers?.['x-api-key'] || input.headers?.['X-API-Key'];\n\nif (!providedKey) {\n  throw new Error('Unauthorized: Missing X-API-Key header');\n}\n\nif (providedKey !== WEBHOOK_API_KEY) {\n  throw new Error('Unauthorized: Invalid API key');\n}\n\nconsole.log('API Key authenticated');\n\n// === MARKETPLACE WHITELIST (reject unknown marketplaces) ===\nconst VALID_MARKETPLACES = [\n  'amazon_us', 'amazon_uk', 'amazon_de', 'amazon_fr', 'amazon_it',\n  'amazon_es', 'amazon_nl', 'amazon_se', 'amazon_pl',\n  'ebay', 'etsy', 'allegro'\n];\n\n// Sanitize text input to prevent prompt injection\n// Strips control sequences and trims excessive length\nconst sanitizeInput = (text, maxLen = 500) => {\n  if (!text || typeof text !== 'string') return text;\n  return text\n    .replace(/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F]/g, '') // strip control chars\n    .replace(/ignore\\s+(all\\s+)?(previous|above|prior)\\s+(instructions?|prompts?)/gi, '') // strip injection attempts\n    .replace(/system\\s*prompt/gi, '')\n    .trim()\n    .slice(0, maxLen);\n};\n\n// === TEST ERROR FLAG ===\nif (input.body?.test_error || input.test_error) {\n  throw new Error('TEST ERROR: Deliberate error triggered via test_error flag');\n}\n\n// === PROCESS PRODUCT DATA ===\n// Support both nested (body.product.title) and flat (body.title) structures\nconst body = input.body || {};\nconst product = body.product || body;\n\nconst title = sanitizeInput(product.title || product.productLine || product.name || 'Product', 300);\nconst brand = sanitizeInput(product.brand || 'Brand', 100);\nconst description = sanitizeInput(product.description || title, 1000);\nconst price = product.price || '29.99';\nconst sku = product.sku || 'SKU-001';\nconst category = product.category || 'General';\n\n// FIX: Accept marketplaces from BOTH root level AND product level\n// Priority: product.marketplaces > body.marketplaces > root level > default\nconst marketplaces = product.target_marketplaces || product.marketplaces || product.marketplace || body.marketplaces || body.marketplace || ['amazon_us'];\nconst specs = product.specifications || {};\n\n// Filter out invalid marketplace names\nconst validatedMarketplaces = (Array.isArray(marketplaces) ? marketplaces : [marketplaces])\n  .filter(mp => VALID_MARKETPLACES.includes(mp.toLowerCase()));\nif (validatedMarketplaces.length === 0) {\n  console.log('Warning: No valid marketplaces found, defaulting to amazon_us');\n}\nconst finalMarketplaces = validatedMarketplaces.length > 0 ? validatedMarketplaces : ['amazon_us'];\n\nconsole.log('Product: ' + title + ' by ' + brand);\nconsole.log('Marketplaces (raw): ' + (Array.isArray(marketplaces) ? marketplaces.join(', ') : marketplaces));\nconsole.log('Marketplaces (valid): ' + finalMarketplaces.join(', '));\n\n// === PROCESS KEYWORD DATA ===\nlet keywords = [];\nlet keywordSource = null;\nlet keywordCount = 0;\n\n// Try keywordFile format first\nconst keywordFile = product.keywordFile || body.keywordFile || null;\nif (keywordFile && keywordFile.data && Array.isArray(keywordFile.data)) {\n  keywordSource = keywordFile.source || 'structured_file';\n  keywords = keywordFile.data\n    .filter(kw => kw.phrase && kw.phrase.length > 0)\n    .sort((a, b) => (b.priority || 0) - (a.priority || 0))\n    .slice(0, 100);\n  keywordCount = keywordFile.keywordCount || keywords.length;\n  console.log('Loaded ' + keywords.length + ' keywords from keywordFile');\n}\n\n// Try keywordData format (direct API array)\nif (keywords.length === 0) {\n  const keywordData = product.keywordData || body.keywordData || [];\n  if (Array.isArray(keywordData) && keywordData.length > 0) {\n    keywordSource = 'datadive_mkl';\n    keywords = keywordData\n      .filter(kw => kw.phrase && kw.phrase.length > 0)\n      .sort((a, b) => (b.priority || b.searchVolume || 0) - (a.priority || a.searchVolume || 0))\n      .slice(0, 100);\n    keywordCount = keywords.length;\n    console.log('Loaded ' + keywords.length + ' keywords from keywordData');\n  }\n}\n\n// Try simple keywords array\nif (keywords.length === 0) {\n  const simpleKeywords = product.keywords || body.keywords || [];\n  if (Array.isArray(simpleKeywords) && simpleKeywords.length > 0) {\n    keywordSource = 'manual';\n    keywords = simpleKeywords.map(kw => {\n      if (typeof kw === 'string') {\n        return { phrase: kw, searchVolume: 0, relevancy: 0.5, priority: 0 };\n      }\n      return kw;\n    }).slice(0, 100);\n    keywordCount = keywords.length;\n    console.log('Loaded ' + keywords.length + ' keywords from keywords array');\n  }\n}\n\nif (keywords.length > 0) {\n  console.log('Top 5: ' + keywords.slice(0, 5).map(k => k.phrase).join(', '));\n} else {\n  console.log('No keyword data provided');\n}\n\nreturn [{ json: { \n  title, brand, description, price, sku, category, marketplaces: finalMarketplaces, specs,\n  keywords,\n  keywordSource,\n  keywordCount,\n  hasKeywordFile: keywords.length > 0\n} }];"
      }
    },
    {
      "id": "groq-bullets",
      "name": "Groq Generate Bullets",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        450,
        0
      ],
      "parameters": {
        "jsCode": "// Multi-Marketplace Bullet Generation v3.4 - SS Knowledge + Language Enforcement\n// EN enforcement, meta-comment filter, model fallback (70b\u21928b)\n// Updated: 2026-02-03\n\nconst input = $input.first().json;\nconst { title, brand, description, category, marketplaces, keywords, keywordSource, hasKeywordFile } = input;\nconst ssKnowledge = input.ss_knowledge || {};\n\nconst GROQ_API_KEY = 'gsk_REDACTED';\nconst DELAYS = { between_calls: 800, retry_base: 1500 };\n\nconst FORBIDDEN_WORDS = {\n  amazon_all: 'buy now, shop now, order now, add to cart, click here, best deal, cheapest, discount, sale, free shipping, #1, best, top rated, cure, heal, treat, prevent, prevents, preventing, antibacterial, antiviral, antimicrobial, therapeutic, amazon\\'s choice, prime eligible, 5-star, limited stock, hurry, replica, fake',\n  amazon_de: 'jetzt kaufen, bester preis, billigste, rabatt, kostenloser versand, beste, bio, oko, organic, heilt, verhindert, antibakteriell, begrenzter vorrat',\n  amazon_pl: 'kup teraz, najlepsza cena, rabat, promocja, darmowa wysylka, najlepszy, leczy, zapobiega, antybakteryjny, ograniczona ilosc',\n  ebay: 'buy now, best deal, free shipping, paypal only, no returns',\n  allegro: 'kup teraz, najlepsza cena, rabat, promocja, darmowa wysylka, najlepszy, ograniczona ilosc'\n};\n\nconst getForbiddenWordsForMp = (mp) => {\n  let words = FORBIDDEN_WORDS.amazon_all;\n  if (mp === 'amazon_de') words += ', ' + FORBIDDEN_WORDS.amazon_de;\n  if (mp === 'amazon_pl') words += ', ' + FORBIDDEN_WORDS.amazon_pl;\n  if (mp === 'ebay') words = FORBIDDEN_WORDS.ebay;\n  if (mp === 'allegro') words = FORBIDDEN_WORDS.allegro;\n  return words;\n};\n\nconst buildKeywordContext = (mp) => {\n  if (!hasKeywordFile || !keywords || keywords.length === 0) return '';\n  const topKw = keywords.slice(0, 20).map(k => k.phrase);\n  const highPriorityKw = keywords.slice(0, 5).map(k => k.phrase);\n  return '\\n\\nKEYWORD RESEARCH (' + keywordSource + '):\\nTOP PRIORITY (must appear in bullets): ' + highPriorityKw.join(', ') + '\\nADDITIONAL (weave naturally): ' + topKw.slice(5).join(', ');\n};\n\n// SS-Enhanced: System prompt with SellerSystems knowledge\nconst getSystemPrompt = (mp) => {\n  const baseMp = mp.startsWith('amazon') ? 'amazon' : mp;\n  if (baseMp === 'amazon') {\n    return 'You are an expert Amazon listing copywriter trained in the SellerSystems Inner Circle methodology by Brandon Young. You have deep knowledge of A9 algorithm optimization, Ranking Juice concepts, and conversion-focused copywriting.\\n\\n' + (ssKnowledge.bullets || '') + '\\n\\n' + (ssKnowledge.marketplace || '');\n  }\n  if (baseMp === 'allegro') {\n    return 'Jestes ekspertem Allegro z wiedza SellerSystems. Pisz TYLKO po polsku.\\n\\n' + (ssKnowledge.marketplace || '');\n  }\n  return 'You are a marketplace listing expert.\\n\\n' + (ssKnowledge.marketplace || '');\n};\n\nconst getPromptForMarketplace = (marketplace) => {\n  const baseInfo = 'Product: ' + title + '\\nBrand: ' + brand + '\\nCategory: ' + category + '\\nDescription: ' + description;\n  const kwContext = buildKeywordContext(marketplace);\n  const forbiddenWords = getForbiddenWordsForMp(marketplace);\n  const forbiddenWarning = '\\n\\nFORBIDDEN WORDS (NEVER use): ' + forbiddenWords;\n  \n  const strategies = {\n    amazon: { strategy: 'inner_circle_5_point', prompt: baseInfo + kwContext + forbiddenWarning + '\\n\\nIMPORTANT: Write ENTIRELY in English. If the product name is in another language, translate it to English first.\\n\\nGenerate 5 bullets using the MANDATORY 5-BULLET STRUCTURE from your training:\\n1. Main USP/differentiator\\n2. Primary feature -> benefit conversion\\n3. Quality/materials -> trust building\\n4. Versatility/use cases -> expand value\\n5. Risk reversal/guarantee\\n\\nEach bullet: CAPS HEADER - benefit text. 200-250 chars. Target different customer avatars. Front-load for mobile (first 150 chars most visible).\\nReturn ONLY 5 bullets, one per line.' },\n    ebay: { strategy: 'ebay_specs_benefits', prompt: baseInfo + kwContext + forbiddenWarning + '\\n\\nIMPORTANT: Write ENTIRELY in English. Translate any non-English product names.\\n\\nGenerate 5 bullets for eBay. Start each with bullet point. Under 100 chars, factual tone. Return ONLY 5 bullets.' },\n    etsy: { strategy: 'etsy_storytelling', prompt: baseInfo + kwContext + forbiddenWarning + '\\n\\nIMPORTANT: Write ENTIRELY in English.\\n\\nGenerate 5 warm storytelling bullets with emojis. Return ONLY 5 bullets.' },\n    allegro: { strategy: 'allegro_polish', prompt: baseInfo + kwContext + forbiddenWarning + '\\n\\nWygeneruj 5 punktow po POLSKU. WAZNE: NIE dodawaj numerow ani znakow na poczatku - tylko czysty tekst punktu! Przyklad dobry: \"Oryginalny produkt marki X\" Przyklad zly: \"1. Oryginalny\" lub \"- Oryginalny\"\\n\\n60-100 znakow kazdy. Zwroc TYLKO 5 punktow.' }\n  };\n  \n  if (marketplace.startsWith('amazon')) return strategies.amazon;\n  return strategies[marketplace] || { strategy: 'generic', prompt: 'Generate 5 bullets for ' + title + '.' };\n};\n\nconst FALLBACKS = {\n  amazon: (b, t, kw) => [\n    'SOLVE YOUR PROBLEM - ' + b + ' ' + t + ' delivers professional results',\n    'PREMIUM QUALITY - High-quality materials for lasting performance',\n    'STANDS OUT - Superior design sets us apart from alternatives',\n    'PERFECT FOR - Adapts to your daily needs at home or work',\n    b.toUpperCase() + ' GUARANTEE - Quality backed by our commitment'\n  ],\n  ebay: (b, t) => ['Brand New ' + b + ' ' + t + ' - 100% Authentic', 'Premium quality - Built to last', 'Fast shipping within 24 hours', '30-day returns accepted', 'Top-rated seller service'],\n  etsy: (b, t) => ['Welcome! This beautiful ' + t + ' is crafted with love', 'Premium materials for exceptional quality', 'Perfect gift for someone special', 'Practical and stylish for everyday', 'We are here to help anytime'],\n  allegro: (b, t) => [b + ' ' + t + ' - 100% oryginalny', 'Wysoka jakosc - materialy premium', 'Ekspresowa wysylka z Polski', '14 dni na zwrot - gwarancja satysfakcji', 'Profesjonalna obsluga klienta'],\n  generic: (b, t) => [b + ' ' + t + ' - Premium', 'High-quality materials', 'Fast shipping', 'Satisfaction guaranteed', 'Excellent support']\n};\n\nconst getFallback = (mp) => {\n  if (mp.startsWith('amazon')) return FALLBACKS.amazon(brand, title, keywords);\n  return (FALLBACKS[mp] || FALLBACKS.generic)(brand, title, keywords);\n};\n\nconst formatAllegroBullets = (bullets) => {\n  return bullets.map((bullet, index) => {\n    let clean = bullet\n      .replace(/^[\\d\\s\\.\\-\\)\\:]+/g, '')\n      .replace(/^[\\u2713\\u2714\\u2022\\u25CF\\u25CB\\u25AA\\u25AB]+\\s*/g, '')\n      .trim();\n    return (index + 1) + '. \\u2713 ' + clean;\n  });\n};\n\nconst MODELS = ['llama-3.3-70b-versatile', 'llama-3.1-8b-instant'];\n\nconst generateBullets = async (mp, retries = 2) => {\n  const { strategy, prompt } = getPromptForMarketplace(mp);\n  const systemPrompt = getSystemPrompt(mp);\n  \n  // Try each model - fallback to 8b-instant if 70b hits rate limit\n  for (const model of MODELS) {\n    for (let attempt = 0; attempt <= retries; attempt++) {\n      try {\n        const response = await this.helpers.httpRequest({\n          method: 'POST',\n          url: 'https://api.groq.com/openai/v1/chat/completions',\n          headers: { 'Authorization': 'Bearer ' + GROQ_API_KEY, 'Content-Type': 'application/json' },\n          body: {\n            model: model,\n            messages: [\n              { role: 'system', content: systemPrompt },\n              { role: 'user', content: prompt }\n            ],\n            temperature: 0.7,\n            max_tokens: 1200\n          },\n          json: true\n        });\n        \n        const content = response.choices && response.choices[0] && response.choices[0].message && response.choices[0].message.content || '';\n        let bullets = content.split('\\n').filter(line => line.trim().length > 15 && line.trim().length < 300);\n        // Strip meta-comments/preamble (LLM instruction leakage)\n        bullets = bullets.filter(line => {\n          const lower = line.toLowerCase().trim();\n          if (lower.startsWith('here are') || lower.startsWith('below are') || lower.startsWith('sure,') || lower.startsWith('sure!')) return false;\n          if (lower.startsWith('oto ') || lower.startsWith('ponizej') || lower.startsWith('poni\u017cej')) return false;\n          if (lower.includes('bullets for') || lower.includes('punkty opisuj') || lower.includes('punkty dla')) return false;\n          if (lower.endsWith(':') && lower.length < 80 && !lower.includes(' - ') && !lower.includes(' | ')) return false;\n          return true;\n        });\n        \n        if (bullets.length >= 3) {\n          if (mp === 'allegro') {\n            bullets = formatAllegroBullets(bullets.slice(0, 5));\n          } else {\n            bullets = bullets.slice(0, 5);\n          }\n          console.log(mp + ': AI generated ' + bullets.length + ' bullets (model: ' + model + ')');\n          return { bullets: bullets, strategy: strategy, aiGenerated: true, ssEnhanced: true, model: model, keywordsUsed: hasKeywordFile };\n        }\n      } catch (e) {\n        console.log(mp + ' ' + model + ' attempt ' + (attempt + 1) + ' failed: ' + e.message);\n        // On rate limit (429), skip remaining retries for this model and try next model\n        if (e.message && e.message.includes('429')) {\n          console.log(mp + ': Rate limit on ' + model + ', trying next model...');\n          break;\n        }\n        if (attempt < retries) await new Promise(r => setTimeout(r, DELAYS.retry_base));\n      }\n    }\n  }\n  \n  console.log(mp + ': Using fallback bullets');\n  let fallbackBullets = getFallback(mp);\n  if (mp === 'allegro') fallbackBullets = formatAllegroBullets(fallbackBullets);\n  return { bullets: fallbackBullets, strategy: strategy + '_fallback', aiGenerated: false, ssEnhanced: false, keywordsUsed: false };\n};\n\nconst bulletsByMarketplace = {};\nconst mpList = Array.isArray(marketplaces) ? marketplaces : ['amazon_us'];\n\nfor (const mp of mpList) {\n  bulletsByMarketplace[mp] = await generateBullets.call(this, mp);\n  if (mpList.indexOf(mp) < mpList.length - 1) await new Promise(r => setTimeout(r, DELAYS.between_calls));\n}\n\nreturn [{ json: { ...input, bulletsByMarketplace, bullets: bulletsByMarketplace[mpList.find(m => m.startsWith('amazon')) || mpList[0]].bullets || [] } }];\n"
      },
      "onError": "continueRegularOutput"
    },
    {
      "id": "groq-description",
      "name": "Groq Generate Description",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        625,
        0
      ],
      "parameters": {
        "jsCode": "// Multi-Marketplace Description Generation v3.4 - SS Knowledge + Language Enforcement\n// EN enforcement, PL strengthened, model fallback (70b\u21928b)\n// Updated: 2026-02-03\nconst input = $input.first().json;\nconst { title, brand, description, category, marketplaces, bulletsByMarketplace, keywords, hasKeywordFile } = input;\nconst ssKnowledge = input.ss_knowledge || {};\n\nconst GROQ_API_KEY = 'gsk_REDACTED';\nconst DELAYS = { between_calls: 800, retry_base: 1500 };\n\nconst FORBIDDEN_WORDS = {\n  amazon_all: 'buy now, shop now, order now, add to cart, click here, best deal, cheapest, discount, sale, #1, best, number one, top rated, cure, heal, treat, prevent, prevents, preventing, antibacterial, antimicrobial, antiviral, therapeutic, amazon\\'s choice, 5-star, limited stock, hurry, replica',\n  amazon_de: 'jetzt kaufen, jetzt bestellen, bester preis, bio, \u00f6ko, organic (without EU cert), heilt, verhindert, antibakteriell, nummer eins',\n  amazon_pl: 'kup teraz, zam\u00f3w teraz, najlepsza cena, najlepszy, leczy, zapobiega, antybakteryjny, numer jeden',\n  ebay: 'buy now, best deal, limited stock, amazon',\n  etsy: 'cheap, discount, amazon, mass-produced',\n  allegro: 'kup teraz, najtaniej, promocja, amazon'\n};\n\nconst getForbiddenWarning = (mp) => {\n  const base = FORBIDDEN_WORDS.amazon_all;\n  let specific = '';\n  if (mp.startsWith('amazon_de')) specific = FORBIDDEN_WORDS.amazon_de;\n  else if (mp.startsWith('amazon_pl')) specific = FORBIDDEN_WORDS.amazon_pl;\n  else if (mp === 'ebay') specific = FORBIDDEN_WORDS.ebay;\n  else if (mp === 'etsy') specific = FORBIDDEN_WORDS.etsy;\n  else if (mp === 'allegro') specific = FORBIDDEN_WORDS.allegro;\n  const allForbidden = specific ? base + ', ' + specific : base;\n  return '\\n\\nFORBIDDEN WORDS (NEVER use): ' + allForbidden + '\\nSAFE ALTERNATIVES: \"helps reduce\" instead of \"prevents\", \"supports\" instead of \"cures\", \"hygienic design\" instead of \"antibacterial\", \"premium\" instead of \"best\"';\n};\n\n// SS-Enhanced: Identify keywords already used in title and bullets\nconst getUsedKeywords = (mp) => {\n  const mpBullets = bulletsByMarketplace && bulletsByMarketplace[mp] ? bulletsByMarketplace[mp].bullets || [] : [];\n  const bulletText = mpBullets.join(' ').toLowerCase();\n  const titleText = (title || '').toLowerCase();\n  const usedInTitleAndBullets = (titleText + ' ' + bulletText);\n  \n  if (!hasKeywordFile || !keywords || keywords.length === 0) return { used: '', remaining: '' };\n  \n  const usedKw = [];\n  const remainingKw = [];\n  keywords.forEach(k => {\n    const phrase = (k.phrase || '').toLowerCase();\n    if (usedInTitleAndBullets.includes(phrase)) {\n      usedKw.push(phrase);\n    } else {\n      remainingKw.push(phrase);\n    }\n  });\n  \n  return { used: usedKw.join(', '), remaining: remainingKw.join(', ') };\n};\n\n// SS-Enhanced: System prompt with description knowledge\nconst getSystemPrompt = (mp) => {\n  const baseMp = mp.startsWith('amazon') ? 'amazon' : mp;\n  if (baseMp === 'amazon') {\n    return 'You are an expert Amazon listing copywriter trained in SellerSystems Inner Circle methodology. Your goal is to MAXIMIZE root word coverage - include keywords NOT already in the title and bullets.\\n\\n' + (ssKnowledge.description || '') + '\\n\\n' + (ssKnowledge.marketplace || '');\n  }\n  if (baseMp === 'allegro') {\n    return 'Jestes ekspertem Allegro z wiedza SellerSystems. Pisz TYLKO po polsku.\\n\\n' + (ssKnowledge.marketplace || '');\n  }\n  return 'You are a marketplace listing expert.\\n\\n' + (ssKnowledge.marketplace || '');\n};\n\nconst getDescPrompt = (mp) => {\n  const baseInfo = 'Product: ' + title + '\\nBrand: ' + brand + '\\nCategory: ' + category + '\\nBase description: ' + description;\n  const forbiddenWarning = getForbiddenWarning(mp);\n  const { used, remaining } = getUsedKeywords(mp);\n  \n  // SS-Enhanced: Tell Groq which keywords are already covered\n  const kwCoverage = used ? '\\n\\nKEYWORDS ALREADY IN TITLE/BULLETS (do NOT repeat heavily): ' + used : '';\n  const kwRemaining = remaining ? '\\nKEYWORDS TO INCLUDE IN DESCRIPTION (maximize coverage): ' + remaining : '';\n  \n  const strategies = {\n    amazon: { strategy: 'inner_circle_a9_ss', prompt: baseInfo + kwCoverage + kwRemaining + forbiddenWarning + '\\n\\nIMPORTANT: Write ENTIRELY in English. Translate any non-English product names to English first.\\n\\nWrite description targeting all 3 layers of A9:\\n1. LEXICAL - include remaining exact keywords listed above\\n2. SEMANTIC (BERT) - use synonyms and related terms\\n3. BEHAVIORAL (COSMO) - describe real use cases\\n\\n3 paragraphs: Lifestyle Hook, Core Value, Trust & Close. 150-300 words.\\nReturn ONLY the description text.' },\n    ebay: { strategy: 'ebay_specs', prompt: baseInfo + forbiddenWarning + '\\n\\nIMPORTANT: Write ENTIRELY in English. Translate any non-English product names.\\n\\nWrite eBay description:\\n1. Condition: Brand New\\n2. Overview (2-3 sentences)\\n3. Specifications (bullets)\\n4. What\\'s Included\\n5. Shipping & Returns\\n\\nDirect factual tone, 100-200 words.\\nReturn ONLY description.' },\n    etsy: { strategy: 'etsy_storytelling', prompt: baseInfo + forbiddenWarning + '\\n\\nIMPORTANT: Write ENTIRELY in English.\\n\\nWrite Etsy STORYTELLING description with artisan warmth:\\n1. Warm welcome\\n2. Story & craftsmanship\\n3. Details that matter\\n4. Perfect for occasions\\n5. Shop appreciation\\n\\nWarm friendly tone, tasteful emojis, 150-250 words.\\nReturn ONLY description.' },\n    allegro: { strategy: 'allegro_polish', prompt: baseInfo + forbiddenWarning + '\\n\\nNapisz opis CALKOWICIE po POLSKU. KAZDE zdanie musi byc po polsku. NIE uzywaj angielskiego.\\n\\nStruktura:\\n1. Naglowek: ' + brand + ' ' + title + '\\n2. Opis produktu\\n3. Cechy (checkmark przed kazdym)\\n4. Wysylka z Polski\\n5. Gwarancja satysfakcji\\n\\n100-200 slow.\\nZwroc TYLKO opis.' }\n  };\n  if (mp.startsWith('amazon')) return strategies.amazon;\n  return strategies[mp] || { strategy: 'generic', prompt: 'Write description for ' + title + '. 100-200 words.' + forbiddenWarning };\n};\n\nconst FALLBACKS = {\n  amazon: (b, t, d) => 'Discover the ' + b + ' ' + t + ', designed to enhance your daily routine. Whether you\\'re looking for reliability, quality, or value, this product delivers.\\n\\nCrafted with premium materials, the ' + b + ' ' + t + ' stands out from alternatives. Thoughtful design ensures lasting performance for beginners and experts alike.\\n\\nWith ' + b + '\\'s commitment to excellence, your purchase is backed by quality craftsmanship and satisfaction. Experience the difference.',\n  ebay: (b, t, d) => 'Condition: Brand New\\n\\n' + b + ' ' + t + ' - exactly what you need.\\n\\nSpecifications:\\n* Premium quality\\n* Authentic ' + b + ' product\\n* Full warranty\\n\\nWhat\\'s Included:\\n* 1x ' + t + '\\n* Original packaging\\n\\nShipping & Returns:\\n* Fast shipping within 24 hours\\n* 30-day money back guarantee',\n  etsy: (b, t, d) => 'Welcome to our shop!\\n\\nThis beautiful ' + b + ' ' + t + ' is crafted with love and attention. We believe in products that bring joy.\\n\\nMade with premium materials, combining quality with practical design.\\n\\nPerfect gift for birthdays, holidays, or just because!\\n\\nThank you for visiting! Your happiness is our priority!',\n  allegro: (b, t, d) => b + ' ' + t + ' - Oryginalny Produkt\\n\\nOpis:\\n' + d + '\\n\\nCechy produktu:\\n\u2713 Wysoka jakosc wykonania\\n\u2713 Oryginalne materialy\\n\u2713 Gwarancja producenta\\n\\nWysylka:\\n\u2713 Ekspresowa wysylka z Polski\\n\u2713 Bezpieczne pakowanie\\n\\n\u2713 14 dni na zwrot\\n\u2713 Gwarancja satysfakcji',\n  generic: (b, t, d) => b + ' ' + t + '\\n\\n' + d + '\\n\\nHigh-quality product. Fast shipping and satisfaction guaranteed.'\n};\n\nconst getFallback = (mp) => {\n  if (mp.startsWith('amazon')) return FALLBACKS.amazon(brand, title, description);\n  return (FALLBACKS[mp] || FALLBACKS.generic)(brand, title, description);\n};\n\nconst MODELS = ['llama-3.3-70b-versatile', 'llama-3.1-8b-instant'];\n\nconst generateDesc = async (mp, retries = 2) => {\n  const { strategy, prompt } = getDescPrompt(mp);\n  const systemPrompt = getSystemPrompt(mp);\n  \n  for (const model of MODELS) {\n  for (let attempt = 0; attempt <= retries; attempt++) {\n    try {\n      // SS-Enhanced: Use system + user messages\n      const response = await this.helpers.httpRequest({\n        method: 'POST',\n        url: 'https://api.groq.com/openai/v1/chat/completions',\n        headers: { 'Authorization': 'Bearer ' + GROQ_API_KEY, 'Content-Type': 'application/json' },\n        body: {\n          model: model,\n          messages: [\n            { role: 'system', content: systemPrompt },\n            { role: 'user', content: prompt }\n          ],\n          temperature: 0.7,\n          max_tokens: 1200\n        },\n        json: true\n      });\n      \n      const content = response.choices && response.choices[0] && response.choices[0].message && response.choices[0].message.content || '';\n      \n      if (content.length > 50) {\n        console.log(mp + ': SS-enhanced description (' + content.length + ' chars)');\n        return { description: content.trim(), strategy, aiGenerated: true, ssEnhanced: true };\n      }\n    } catch (e) {\n      console.log(mp + ' ' + model + ' desc attempt ' + (attempt + 1) + ' failed: ' + e.message);\n      if (e.message && e.message.includes('429')) {\n        console.log(mp + ': Rate limit on ' + model + ', trying next model...');\n        break;\n      }\n      if (attempt < retries) await new Promise(r => setTimeout(r, DELAYS.retry_base));\n    }\n  }\n  }\n  \n  console.log(mp + ': Using fallback description');\n  return { description: getFallback(mp), strategy: strategy + '_fallback', aiGenerated: false, ssEnhanced: false };\n};\n\nconst descriptionsByMarketplace = {};\nconst mpList = Array.isArray(marketplaces) ? marketplaces : ['amazon_us'];\n\nfor (const mp of mpList) {\n  descriptionsByMarketplace[mp] = await generateDesc.call(this, mp);\n  if (mpList.indexOf(mp) < mpList.length - 1) await new Promise(r => setTimeout(r, DELAYS.between_calls));\n}\n\nreturn [{ json: { ...input, descriptionsByMarketplace, description: descriptionsByMarketplace[mpList.find(m => m.startsWith('amazon')) || mpList[0]]?.description || description } }];\n"
      },
      "onError": "continueRegularOutput"
    },
    {
      "id": "generate-listings",
      "name": "Generate Listings",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        800,
        0
      ],
      "parameters": {
        "jsCode": "// Generate Listings v2.3 - TITLE LENGTH + ETSY 13 TAGS + EBAY SPECIFICS\n// Updated: 2026-02-03\n// CRITICAL: TITLE_LIMITS must match Groq Translate EU node - if you change limits here, change there too!\n\nconst input = $input.first().json;\nconst title = input.title || 'Product';\nconst brand = input.brand || 'Brand';\nconst category = input.category || 'General';\nconst price = input.price || '0';\nconst sku = input.sku || '';\nconst specs = input.specs || {};\nconst keywords = input.keywords || [];\nconst marketplaces = input.marketplaces || ['amazon', 'ebay', 'etsy', 'allegro'];\nconst bulletsByMarketplace = input.bulletsByMarketplace || {};\nconst descriptionsByMarketplace = input.descriptionsByMarketplace || {};\n\n// Helper: Get base marketplace name (amazon_us -> amazon)\nfunction getBaseMp(mp) {\n  if (mp.startsWith('amazon')) return 'amazon';\n  return mp;\n}\n\n// TITLE LENGTH REQUIREMENTS (ENFORCED!)\nconst TITLE_LIMITS = {\n  amazon: { min: 80, max: 200 },\n  ebay: { min: 60, max: 80 },\n  etsy: { min: 80, max: 140 },\n  allegro: { min: 30, max: 50 }\n};\n\n// Extend title to meet minimum length with SEO keywords\nfunction extendTitle(baseTitle, marketplace, brand, category, kws) {\n  const baseMp = getBaseMp(marketplace);\n  const limits = TITLE_LIMITS[baseMp];\n  if (!limits) return baseTitle;\n  let extended = baseTitle;\n  \n  const paddingWords = {\n    amazon: ['Premium Quality', 'Professional Grade', 'Durable Construction', 'High Performance', 'Heavy Duty', 'Multi-Purpose', 'Kitchen Essentials', 'Home & Kitchen'],\n    ebay: ['NEW', 'Fast Shipping', 'Top Quality', 'Authentic', 'Genuine Brand', '100% Original', 'Factory Sealed'],\n    etsy: ['Handmade', 'Unique Gift', 'Custom Made', 'Gift for Her', 'Gift for Him', 'Birthday Gift', 'Christmas Gift', 'Anniversary Gift', 'Personalized'],\n    allegro: ['Premium', 'Najwyzsza Jakosc', 'Oryginalny Produkt']\n  };\n  \n  const words = paddingWords[baseMp] || paddingWords.amazon;\n  let idx = 0;\n  \n  // Add keywords from research first\n  if (kws && kws.length > 0) {\n    kws.slice(0, 3).forEach(function(kw) {\n      const keyword = kw.keyword || kw.phrase || kw;\n      if (keyword && extended.length < limits.min && !extended.toLowerCase().includes(keyword.toLowerCase())) {\n        extended = extended + ' ' + keyword;\n      }\n    });\n  }\n  \n  // Then add padding words\n  while (extended.length < limits.min && idx < words.length) {\n    if (!extended.toLowerCase().includes(words[idx].toLowerCase())) {\n      extended = extended + ' ' + words[idx];\n    }\n    idx++;\n  }\n  \n  // Add category if still short\n  if (extended.length < limits.min && category && !extended.toLowerCase().includes(category.toLowerCase())) {\n    extended = extended + ' for ' + category;\n  }\n  \n  // Truncate if too long\n  if (extended.length > limits.max) {\n    extended = extended.substring(0, limits.max - 3).trim() + '...';\n  }\n  \n  return extended.trim();\n}\n\n// Clean Amazon bullets - remove * and bullet prefixes\nfunction cleanBullets(bullets) {\n  if (!Array.isArray(bullets)) return [];\n  return bullets.map(function(b) {\n    // Remove: *, bullet char, -, numbers with dots\n    return b.replace(/^[*\\u2022\\-]+\\s*/, '').replace(/^\\d+\\.\\s*/, '').trim();\n  });\n}\n\n// Generate exactly 13 Etsy tags (CRITICAL for Etsy SEO!)\nfunction generateEtsyTags(productTitle, brandName, cat, kws) {\n  const titleWords = productTitle.toLowerCase().split(' ').filter(function(w) { return w.length > 2; });\n  \n  const baseTags = [\n    titleWords.slice(0, 2).join(' ').substring(0, 20) || 'unique item',\n    'handmade gift',\n    'unique gift',\n    'gift for her',\n    'gift for him',\n    'birthday gift',\n    'christmas gift',\n    'anniversary gift',\n    'personalized gift',\n    'custom made',\n    (brandName || 'artisan').toLowerCase().substring(0, 20),\n    (cat || 'home goods').toLowerCase().substring(0, 20),\n    'special occasion'\n  ];\n  \n  // Add keywords if available\n  if (kws && kws.length > 0) {\n    kws.slice(0, 5).forEach(function(kw) {\n      const tag = (kw.keyword || kw.phrase || kw || '').toLowerCase().substring(0, 20);\n      if (tag && tag.length > 2) {\n        baseTags.push(tag);\n      }\n    });\n  }\n  \n  // Deduplicate and ensure 13 tags\n  const seen = {};\n  const uniqueTags = [];\n  baseTags.forEach(function(t) {\n    const clean = t.trim().substring(0, 20);\n    if (clean && !seen[clean] && uniqueTags.length < 13) {\n      seen[clean] = true;\n      uniqueTags.push(clean);\n    }\n  });\n  \n  // Pad with generic tags if needed\n  const padTags = ['home decor', 'minimalist style', 'boho chic', 'vintage inspired', 'modern design', 'eco friendly', 'sustainable', 'artisan made'];\n  let padIdx = 0;\n  while (uniqueTags.length < 13 && padIdx < padTags.length) {\n    if (!seen[padTags[padIdx]]) {\n      uniqueTags.push(padTags[padIdx]);\n      seen[padTags[padIdx]] = true;\n    }\n    padIdx++;\n  }\n  \n  return uniqueTags.slice(0, 13);\n}\n\n// Generate eBay item_specifics (CRITICAL for Cassini ranking!)\nfunction generateEbaySpecifics(brandName, cat, productSpecs) {\n  const specifics = {\n    'Brand': brandName || 'Unbranded',\n    'Type': cat || 'General',\n    'Condition': 'New',\n    'Country/Region of Manufacture': 'China',\n    'Material': productSpecs.material || 'See Description',\n    'Color': productSpecs.color || 'As Pictured',\n    'Size': productSpecs.size || 'Standard',\n    'Model': productSpecs.model || 'See Description',\n    'MPN': productSpecs.mpn || 'Does Not Apply',\n    'UPC': productSpecs.upc || 'Does Not Apply'\n  };\n  \n  // Add any additional specs from input\n  if (productSpecs && typeof productSpecs === 'object') {\n    Object.keys(productSpecs).forEach(function(key) {\n      var val = productSpecs[key];\n      if (val && typeof val === 'string' && val.length > 0) {\n        var capitalKey = key.charAt(0).toUpperCase() + key.slice(1).replace(/_/g, ' ');\n        if (!specifics[capitalKey]) {\n          specifics[capitalKey] = val;\n        }\n      }\n    });\n  }\n  \n  return specifics;\n}\n\n// Build listings for each marketplace\nconst listings = {};\n\nmarketplaces.forEach(function(mp) {\n  const mpLower = mp.toLowerCase();\n  const baseMp = getBaseMp(mpLower);\n  const baseTitle = (brand + ' ' + title).trim();\n  \n  // Get marketplace-specific content\n  const mpBulletData = bulletsByMarketplace[mpLower] || {};\n  const mpDescData = descriptionsByMarketplace[mpLower] || {};\n  const mpBullets = mpBulletData.bullets || [];\n  const mpDesc = mpDescData.description || input.description || '';\n  \n  // FIX: Clean bullets for ALL Amazon variants (amazon_us, amazon_de, etc.)\n  const cleanedBullets = baseMp === 'amazon' ? cleanBullets(mpBullets) : mpBullets;\n  \n  // Create listing object\n  listings[mpLower] = {\n    title: extendTitle(baseTitle, mpLower, brand, category, keywords),\n    title_length: 0,\n    bullets: cleanedBullets,\n    bullets_strategy: mpBulletData.strategy || 'default',\n    keywords_used: keywords.length > 0,\n    description: mpDesc,\n    description_strategy: mpDescData.strategy || 'default',\n    backend_keywords: keywords.length > 0 \n      ? keywords.map(function(k) { return k.keyword || k.phrase || k; }).join(' ').substring(0, 250)\n      : (title + ' ' + brand + ' ' + category).toLowerCase().substring(0, 250),\n    backend_keywords_count: Math.max(keywords.length, 1),\n    price: price,\n    language: mpLower === 'allegro' || mpLower === 'amazon_pl' ? 'PL' : 'EN'\n  };\n  \n  // Set actual title length\n  listings[mpLower].title_length = listings[mpLower].title.length;\n  \n  // ETSY: Add exactly 13 tags (REQUIRED!)\n  if (baseMp === 'etsy') {\n    listings[mpLower].tags = generateEtsyTags(title, brand, category, keywords);\n    listings[mpLower].tags_count = listings[mpLower].tags.length;\n  }\n  \n  // EBAY: Add item_specifics (CRITICAL for ranking!)\n  if (baseMp === 'ebay') {\n    listings[mpLower].item_specifics = generateEbaySpecifics(brand, category, specs);\n  }\n});\n\n// Build keyword statistics\nconst keywordStats = {\n  source: input.keywordSource || null,\n  total_uploaded: keywords.length,\n  used_in_backend: Math.max(keywords.length, 1),\n  keywords_in_bullets: keywords.length > 0\n};\n\nreturn [{\n  json: {\n    ...input,\n    listings: listings,\n    keywordStats: keywordStats,\n    generatedAt: new Date().toISOString()\n  }\n}];"
      }
    },
    {
      "id": "groq-translate",
      "name": "Groq Translate EU",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        975,
        0
      ],
      "parameters": {
        "jsCode": "// Groq Translate EU v3.14 - Bullet quality verification + retry\n// Fixes: product_name mode, Jogi\u2192Yoga, BULLET N: strip, PL name in descriptions\n// Updated: 2026-02-03\n\nconst data = $input.first().json;\nconst listings = { ...data.listings };\nconst debugLog = [];\n\n// 3 Groq API keys for rotation on rate limit\nconst GROQ_API_KEYS = [\n  'gsk_REDACTED',  // Primary\n  'gsk_REDACTED',  // Backup #1\n  'gsk_REDACTED'   // Backup #2\n];\nlet currentKeyIndex = 0;\n\nconst httpRequest = this.helpers.httpRequest.bind(this.helpers);\nconst sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));\n\nconst DELAYS = { \n  between_translations: 2000,\n  retry_base: 3000,\n  between_marketplaces: 1500\n};\n\nconst TITLE_LIMITS = {\n  amazon: { min: 80, max: 200 },\n  ebay: { min: 60, max: 80 },\n  etsy: { min: 80, max: 140 },\n  allegro: { min: 30, max: 50 }\n};\n\nconst TITLE_PADDING = {\n  DE: ['Premium-Qualit\u00e4t', 'Professionell', 'Hochwertig', 'Langlebig', 'Erstklassig'],\n  FR: ['Haute Qualit\u00e9', 'Premium', 'Professionnel', 'Durable', 'Excellence'],\n  IT: ['Alta Qualit\u00e0', 'Premium', 'Professionale', 'Durevole', 'Eccellente'],\n  ES: ['Alta Calidad', 'Premium', 'Profesional', 'Duradero', 'Excelente'],\n  NL: ['Hoogwaardige', 'Premium Kwaliteit', 'Professioneel', 'Duurzaam'],\n  SV: ['H\u00f6gkvalitativ', 'Premium', 'Professionell', 'H\u00e5llbar'],\n  PL: ['Wysoka Jako\u015b\u0107', 'Premium', 'Profesjonalny', 'Trwa\u0142y', 'Doskona\u0142y'],\n  EN: ['Premium Quality', 'Professional Grade', 'Heavy Duty', 'Durable', 'Multi-Purpose']\n};\n\ndebugLog.push('=== Groq Translate EU v3.13 (title lang verify + retry) ===');\ndebugLog.push(`Available API keys: ${GROQ_API_KEYS.length}`);\n\nfunction switchToNextKey() {\n  if (currentKeyIndex < GROQ_API_KEYS.length - 1) {\n    currentKeyIndex++;\n    debugLog.push(`Switched to key #${currentKeyIndex + 1}`);\n    return true;\n  }\n  debugLog.push('All keys exhausted!');\n  return false;\n}\n\nasync function translateWithGroq(text, targetLang, mode) {\n  const langNames = { DE: 'German', PL: 'Polish', FR: 'French', IT: 'Italian', ES: 'Spanish', NL: 'Dutch', SV: 'Swedish', EN: 'English' };\n  const langName = langNames[targetLang] || 'German';\n  \n  // Mode-aware system prompt: specialized for bullets and product names\n  let systemMsg;\n  if (mode === 'product_name') {\n    systemMsg = `You are a professional e-commerce translator. Translate this product name from its original language to ${langName}. IMPORTANT RULES:\n- This is a PRODUCT NAME for an online listing, not a person's name\n- Translate ALL words including sport/activity terms (e.g., \"Jogi\"/\"Yoga\" \u2192 use the ${langName} word for Yoga)\n- \"Mata do Jogi\" = \"Yoga Mat\" in English, \"Yogamatte\" in German\n- \"Antypo\u015blizgowa\" = \"Anti-Slip\"/\"Non-Slip\" in English, \"Antirutsch\"/\"Rutschfest\" in German\n- Return ONLY the translated product name, nothing else`;\n  } else if (mode === 'bullets') {\n    systemMsg = `You are a translator. Translate each line below to ${langName}. RULES:\n- Translate EACH line word-by-word to ${langName}\n- Keep the SAME number of lines (one translated line per input line)\n- Keep CAPS HEADER format (translate the header words too)\n- Keep bullet markers (-, \u2022, numbers)\n- Do NOT add category labels, section headers, or framework structure\n- Do NOT reorganize or regenerate content\n- Return ONLY the translated lines`;\n  } else {\n    systemMsg = `You are a professional translator. Translate the user's text to ${langName}. Return ONLY the translated text. No explanations, no commentary, no instructions.`;\n  }\n  const userMsg = text;\n  \n  for (let attempt = 0; attempt < 6; attempt++) {\n    try {\n      const response = await httpRequest({\n        method: 'POST',\n        url: 'https://api.groq.com/openai/v1/chat/completions',\n        headers: {\n          'Authorization': `Bearer ${GROQ_API_KEYS[currentKeyIndex]}`,\n          'Content-Type': 'application/json'\n        },\n        body: {\n          model: 'llama-3.3-70b-versatile',\n          messages: [\n            { role: 'system', content: systemMsg },\n            { role: 'user', content: userMsg }\n          ],\n          temperature: 0.3,\n          max_tokens: 1500\n        },\n        json: true\n      });\n      \n      if (response?.choices?.[0]) {\n        let result = response.choices[0].message.content.trim();\n        // Safety net: strip instruction echo if LLM repeated the prompt\n        if (result.includes('\\n\\n')) {\n          const parts = result.split('\\n\\n');\n          const first = parts[0].toLowerCase();\n          const echoWords = ['must', 'critical', 'translate', 'muss', 'kritisch', 'traduire', 'tradurre', 'traducir', 'przet\u0142umacz', 'tylko'];\n          if (echoWords.some(w => first.includes(w))) {\n            result = parts.slice(1).join('\\n\\n').trim();\n          }\n        }\n        // Strip \"Translation:\" prefixes in any language\n        result = result.replace(/^(Translation|\u00dcbersetzung|Traduction|Traducci\u00f3n|Traduzione|T\u0142umaczenie)\\s*:\\s*/i, '');\n        return result;\n      }\n      throw new Error('Invalid response');\n    } catch (error) {\n      const is429 = error.message.includes('429');\n      \n      if (is429) {\n        debugLog.push(`Rate limited (key #${currentKeyIndex + 1})`);\n        if (switchToNextKey()) {\n          await sleep(1000);\n          continue;\n        }\n      }\n      \n      if (attempt < 5) {\n        await sleep(DELAYS.retry_base * (attempt + 1));\n      } else {\n        throw error;\n      }\n    }\n  }\n}\n\nfunction fixPolishGrammar(text) {\n  if (!text) return text;\n  return text\n    .replace(/\\bz stali/gi, 'ze stali')\n    .replace(/\\bz szk\u0142a/gi, 'ze szk\u0142a')\n    .replace(/\\bz srebra/gi, 'ze srebra');\n}\n\n// Strip newlines and LLM explanation artifacts from titles\n// Groq sometimes returns \"X becomes Y\" or \"Since the text is already...\" instead of clean translation\nfunction cleanTitleArtifacts(title) {\n  if (!title) return title;\n  // Strip parenthetical LLM meta-comments: \"(No translation needed)\", \"(Already in English)\", etc.\n  let clean = title.replace(/\\s*\\((No translation|Already|Note|Translation|Original)[^)]*\\)/gi, '').trim();\n  // Strip newlines \u2014 titles must be single-line\n  if (clean.includes('\\n')) {\n    const lines = clean.split('\\n')\n      .map(l => l.trim())\n      .filter(l => l.length > 5)\n      .filter(l => !/^(becomes|since|here is|note:|translation:)/i.test(l));\n    clean = (lines[0] || clean.split('\\n')[0]).trim();\n  }\n  return clean;\n}\n\nfunction mergeBulletPairs(lines) {\n  // Merge header+content split: short header line followed by long content paragraph\n  // e.g. \"**HEADER** - Subtitle\" (58ch) + \"Content paragraph...\" (272ch) \u2192 merged\n  const merged = [];\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i].trim();\n    const nextLine = i + 1 < lines.length ? lines[i + 1].trim() : '';\n    const isShort = line.length < 80;\n    const nextIsLong = nextLine.length > 100;\n    const lengthRatio = nextLine.length > 3 * line.length;\n    const hasBoldMarkers = line.includes('**');\n    if (isShort && nextIsLong && (lengthRatio || hasBoldMarkers)) {\n      merged.push(line + ' ' + nextLine);\n      i++;\n    } else {\n      merged.push(line);\n    }\n  }\n  return merged;\n}\n\nfunction cleanBulletArtifacts(bullet) {\n  if (!bullet) return bullet;\n  // Remove \"BULLET N:\" or \"**BULLET N:**\" prefixes\n  let clean = bullet.replace(/^\\*?\\*?\\s*BULLET\\s*\\d+\\s*:?\\*?\\*?\\s*/i, '').trim();\n  // Remove leading \"N.\" or \"N)\" numbering if followed by content\n  clean = clean.replace(/^\\d+[.):]\\s*/, '').trim();\n  return clean || bullet;\n}\n\nfunction extendTitle(title, lang, minLen, maxLen) {\n  let ext = title.trim();\n  if (ext.length >= minLen) {\n    return ext.length > maxLen ? ext.slice(0, maxLen - 3).trim() + '...' : ext;\n  }\n  const padding = TITLE_PADDING[lang] || TITLE_PADDING.DE;\n  for (const word of padding) {\n    if (ext.length >= minLen) break;\n    if (!ext.toLowerCase().includes(word.toLowerCase())) ext += ' ' + word;\n  }\n  return ext.length > maxLen ? ext.slice(0, maxLen - 3).trim() + '...' : ext.trim();\n}\n\nasync function translateListing(listing, targetLang, marketplace, originalData) {\n  const baseMp = marketplace.startsWith('amazon') ? 'amazon' : marketplace;\n  const limits = TITLE_LIMITS[baseMp] || TITLE_LIMITS.amazon;\n  \n  let translatedTitle, translatedBullets, translatedDesc;\n  let usedFallback = false;\n  \n  try {\n    debugLog.push(`[${marketplace}] Translating to ${targetLang}`);\n    \n    // Translate RAW product name (not padded title) to avoid LLM treating PL as proper noun\n    // listing.title = \"Brand ProductNamePL keyword1 padding...\" (mixed languages, confuses LLM)\n    // originalData.title = \"ProductNamePL\" (clean, single language \u2014 translates properly)\n    const brandPrefix = (originalData.brand || '').trim();\n    const rawProductName = originalData.title || listing.title;\n    let productToTranslate = rawProductName;\n    // Strip brand if present in raw name too\n    if (brandPrefix && productToTranslate.startsWith(brandPrefix)) {\n      productToTranslate = productToTranslate.slice(brandPrefix.length).trim();\n    }\n    translatedTitle = await translateWithGroq(productToTranslate, targetLang, 'product_name');\n    translatedTitle = translatedTitle.replace(/^[\"']|[\"']$/g, '').trim();\n    translatedTitle = cleanTitleArtifacts(translatedTitle);\n    // Verify title is in target language \u2014 retry if source language (PL/EN) detected\n    const titleChk = ' ' + translatedTitle.toLowerCase() + ' ';\n    let titleRetry = false;\n    // Polish chars in non-PL title = untranslated\n    if (targetLang !== 'PL' && /[\u0105\u0107\u0119\u0142\u015b\u017a\u017c]/i.test(translatedTitle)) {\n      titleRetry = true;\n      debugLog.push(`[${marketplace}] Title has Polish chars, retrying`);\n    }\n    if (!titleRetry) {\n      // PL-specific function words (won't appear in DE/FR/IT/ES product names)\n      const plOnly = [' ze ', ' dla ', ' si\u0119 '];\n      // EN function words (shouldn't be in non-EN product names)\n      const enOnly = [' with ', ' the '];\n      if (targetLang !== 'PL' && plOnly.some(w => titleChk.includes(w))) {\n        titleRetry = true;\n        debugLog.push(`[${marketplace}] Title has PL words, retrying`);\n      } else if (enOnly.some(w => titleChk.includes(w))) {\n        titleRetry = true;\n        debugLog.push(`[${marketplace}] Title has EN words, retrying`);\n      }\n    }\n    if (titleRetry) {\n      await sleep(DELAYS.between_translations);\n      const langFull = {DE:'German',PL:'Polish',FR:'French',IT:'Italian',ES:'Spanish',NL:'Dutch',SV:'Swedish'}[targetLang] || targetLang;\n      const retryT = await translateWithGroq(\n        'TRANSLATE THIS PRODUCT NAME TO ' + langFull + ': ' + productToTranslate,\n        targetLang, 'product_name'\n      );\n      if (retryT && retryT.length > 5) {\n        translatedTitle = retryT.replace(/^[\"']|[\"']$/g, '').trim();\n        translatedTitle = cleanTitleArtifacts(translatedTitle);\n        debugLog.push(`[${marketplace}] Title retry applied`);\n      }\n    }\n    if (targetLang === 'PL') translatedTitle = fixPolishGrammar(translatedTitle);\n    // Rebuild: brand + translated product name, then pad to meet min length\n    translatedTitle = brandPrefix ? (brandPrefix + ' ' + translatedTitle).trim() : translatedTitle;\n    translatedTitle = extendTitle(translatedTitle, targetLang, limits.min, limits.max);\n    debugLog.push(`[${marketplace}] Title OK (from raw product name)`);\n    \n    // Pre-replace Polish product name in description with translated version\n    // Prevents \"Mata do Jogi Antypo\u015blizgowa\" appearing in German/French/etc descriptions\n    const escapeRx = (s) => s.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n    let cleanTranslatedName = translatedTitle;\n    if (brandPrefix) cleanTranslatedName = cleanTranslatedName.replace(brandPrefix, '').trim();\n    const padWords = TITLE_PADDING[targetLang] || [];\n    for (const pw of padWords) {\n      cleanTranslatedName = cleanTranslatedName.replace(new RegExp('\\\\s*' + escapeRx(pw) + '$', 'i'), '').trim();\n    }\n    if (productToTranslate && productToTranslate.length > 5 && cleanTranslatedName.length > 3) {\n      const fullPolishName = brandPrefix ? (brandPrefix + ' ' + productToTranslate) : productToTranslate;\n      listing.description = listing.description\n        .replace(new RegExp(escapeRx(fullPolishName), 'gi'), brandPrefix ? (brandPrefix + ' ' + cleanTranslatedName) : cleanTranslatedName)\n        .replace(new RegExp(escapeRx(productToTranslate), 'gi'), cleanTranslatedName);\n      debugLog.push(`[${marketplace}] Replaced PL product name in desc`);\n    }\n    \n    await sleep(DELAYS.between_translations);\n    \n    const bulletsText = listing.bullets.join('\\n');\n    try {\n      const bulletsResponse = await translateWithGroq(bulletsText, targetLang, 'bullets');\n      let parsed = bulletsResponse.split('\\n').filter(l => l.trim().length > 10);\n      \n      // Merge header+content split (IT/ES/NL pattern)\n      parsed = mergeBulletPairs(parsed);\n      \n      // Filter meta-comment bullets (framework headers LLM generates instead of translating)\n      parsed = parsed.filter(b => {\n        const stripped = b.replace(/\\*\\*/g, '').trim();\n        // Skip lines that are JUST uppercase category headers (no product content)\n        if (/^[A-Z\\u00C0-\\u024F\\s\\/\\-\\>\u2192:&]+$/.test(stripped) && stripped.length < 80) return false;\n        // Skip lines that are framework labels (MAIN USP, DIFFERENTIATOR, etc.)\n        if (/^(BULLET\\s*\\d|MAIN\\s+USP|DIFFERENTIATOR|KEY\\s+(SELLING|FEATURE)|QUALITY|TRUST|PRIMARY\\s+FEATURE|VERSATIL)/i.test(stripped)) return false;\n        // Skip lines too short to be real bullets\n        if (stripped.length < 30) return false;\n        return true;\n      }).slice(0, 5);\n      parsed = parsed.map(b => cleanBulletArtifacts(b));\n      if (targetLang === 'PL') parsed = parsed.map(b => fixPolishGrammar(b));\n      \n      // Bullet quality retry: if < 5 good bullets, retry with simpler prompt\n      if (parsed.length < 5) {\n        debugLog.push(`[${marketplace}] Only ${parsed.length} bullets, retrying translation...`);\n        await sleep(DELAYS.between_translations);\n        const langFull = {DE:'German',PL:'Polish',FR:'French',IT:'Italian',ES:'Spanish',NL:'Dutch',SV:'Swedish'}[targetLang] || targetLang;\n        const retryBulletsText = listing.bullets.map((b, i) => (i+1) + '. ' + b.replace(/\\*\\*/g, '').replace(/^[-\u2022]\\s*/, '').trim()).join('\\n');\n        try {\n          const retryResp = await translateWithGroq(\n            'Translate these 5 product bullet points to ' + langFull + '. CRITICAL RULES:\\n1. Return EXACTLY 5 lines\\n2. Each line = **BOLD HEADER** - full description paragraph (100+ chars)\\n3. Do NOT split header and description into separate lines\\n4. Each bullet must be self-contained on ONE line\\n\\n' + retryBulletsText,\n            targetLang, 'bullets'\n          );\n          let retryParsed = retryResp.split('\\n')\n            .map(l => l.trim())\n            .filter(l => l.length > 10);\n          retryParsed = mergeBulletPairs(retryParsed);\n          retryParsed = retryParsed\n            .filter(l => l.replace(/\\*\\*/g, '').trim().length > 30)\n            .map(b => cleanBulletArtifacts(b))\n            .slice(0, 5);\n          if (targetLang === 'PL') retryParsed = retryParsed.map(b => fixPolishGrammar(b));\n          if (retryParsed.length > parsed.length) {\n            parsed = retryParsed;\n            debugLog.push(`[${marketplace}] Bullet retry OK: ${retryParsed.length} bullets`);\n          }\n        } catch (retryErr) {\n          debugLog.push(`[${marketplace}] Bullet retry failed: ${retryErr.message}`);\n        }\n      }\n      \n      translatedBullets = parsed.length >= 3 ? parsed : listing.bullets;\n      debugLog.push(`[${marketplace}] Bullets: ${translatedBullets.length}`);\n    } catch (e) {\n      debugLog.push(`[${marketplace}] Bullets fallback`);\n      translatedBullets = listing.bullets;\n    }\n    \n    await sleep(DELAYS.between_translations);\n    \n    translatedDesc = await translateWithGroq(listing.description, targetLang);\n    // Verify translation actually changed language \u2014 LLM sometimes returns source text\n    const descHasTarget = (() => {\n      const d = ' ' + translatedDesc.toLowerCase() + ' ';\n      const markers = {\n        DE: [' und ', ' mit ', ' aus ', ' der ', ' die ', ' das '],\n        PL: [' do ', ' ze ', ' dla ', ' na ', ' jest ', ' si\u0119 '],\n        FR: [' et ', ' avec ', ' dans ', ' pour ', ' les '],\n        IT: [' e ', ' con ', ' della ', ' per ', ' una '],\n        ES: [' y ', ' con ', ' para ', ' una ', ' del ']\n      };\n      const check = markers[targetLang] || [];\n      return check.filter(w => d.includes(w)).length >= 2;\n    })();\n    if (!descHasTarget && translatedDesc.length > 100) {\n      debugLog.push(`[${marketplace}] Description may not be in ${targetLang}, retrying...`);\n      await sleep(DELAYS.between_translations);\n      const retry = await translateWithGroq(\n        'TRANSLATE TO ' + targetLang + ': ' + listing.description.slice(0, 1500),\n        targetLang\n      );\n      if (retry && retry.length > 50) translatedDesc = retry;\n    }\n    if (targetLang === 'PL') translatedDesc = fixPolishGrammar(translatedDesc);\n    debugLog.push(`[${marketplace}] Description OK`);\n    \n  } catch (error) {\n    debugLog.push(`[${marketplace}] FALLBACK: ${error.message}`);\n    usedFallback = true;\n    \n    const brand = originalData.brand || 'Brand';\n    const origTitle = originalData.title || 'Product';\n    let fallbackTitle = `${brand} ${origTitle}`;\n    const padding = TITLE_PADDING[targetLang] || TITLE_PADDING.DE;\n    for (const word of padding) {\n      if (fallbackTitle.length >= limits.min) break;\n      fallbackTitle += ' ' + word;\n    }\n    translatedTitle = extendTitle(fallbackTitle, targetLang, limits.min, limits.max);\n    translatedBullets = listing.bullets;\n    translatedDesc = listing.description;\n  }\n  \n  return {\n    ...listing,\n    title: translatedTitle,\n    title_length: translatedTitle.length,\n    bullets: translatedBullets,\n    description: translatedDesc,\n    language: targetLang,\n    translated: !usedFallback,\n    fallback_used: usedFallback\n  };\n}\n\nconst LANG_MAP = {\n  allegro: 'PL',\n  amazon_pl: 'PL',\n  amazon_de: 'DE',\n  amazon_fr: 'FR',\n  amazon_it: 'IT',\n  amazon_es: 'ES',\n  amazon_nl: 'NL',\n  amazon_se: 'SV'\n};\n\ntry {\n  for (const [mp, lang] of Object.entries(LANG_MAP)) {\n    if (listings[mp]) {\n      listings[mp] = await translateListing(listings[mp], lang, mp, data);\n      await sleep(DELAYS.between_marketplaces);\n    }\n  }\n  // Translate titles to English for EN markets if product name is non-English\n  const EN_MARKETS = ['amazon_us', 'amazon_uk', 'ebay', 'etsy'];\n  // Detect non-English text: diacritics OR common non-English word patterns\n  const looksNonEnglish = (text) => {\n    if (/[^\\x00-\\x7F]/.test(text)) return true;\n    const lower = ' ' + text.toLowerCase() + ' ';\n    const patterns = [' do ', ' ze ', ' z ', ' dla ', ' na ', ' nie ', ' od ', ' lub ', ' jak ', ' jest ', ' czosnku ', ' stali ', ' aus ', ' und ', ' fuer ', ' mit ', ' von ', ' der ', ' die ', ' das ', ' pour ', ' avec ', ' dans ', ' para ', ' con ', ' della '];\n    if (patterns.some(p => lower.includes(p))) return true;\n    // Polish word suffixes (instrumental/genitive case: filtrem, jonizatorem, powietrza)\n    if (/\\b\\w+(iem|rem|torem|\u00f3wk|o\u015bci|acja|aniu|eniu|owiec)\\b/i.test(text)) return true;\n    return false;\n  };\n  \n  // Translate raw product name to EN once, then replace in each EN market title\n  const origProductTitle = data.title || '';\n  let enProductNameCache = null;\n  if (origProductTitle && looksNonEnglish(origProductTitle)) {\n    try {\n      enProductNameCache = await translateWithGroq(origProductTitle, 'EN', 'product_name');\n      enProductNameCache = enProductNameCache.replace(/^[\"']|[\"']$/g, '').trim();\n      debugLog.push(`EN product name: \"${enProductNameCache}\"`);\n    } catch(e) {\n      debugLog.push(`EN product name translation failed: ${e.message}`);\n    }\n    await sleep(DELAYS.between_translations);\n  }\n  \n  const escRegex = (s) => s.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n  for (const mp of EN_MARKETS) {\n    if (listings[mp] && looksNonEnglish(listings[mp].title)) {\n      debugLog.push(`[${mp}] Title has non-English chars, translating to EN`);\n      try {\n        let enTitle = listings[mp].title;\n        // Replace Polish product name with cached EN translation (gives LLM a head start)\n        if (enProductNameCache && origProductTitle) {\n          enTitle = enTitle.replace(new RegExp(escRegex(origProductTitle), 'gi'), enProductNameCache);\n        }\n        // ALWAYS translate full title to catch remaining PL keywords used as title padding\n        enTitle = await translateWithGroq(enTitle, 'EN');\n        enTitle = enTitle.replace(/^[\"']|[\"']$/g, '').trim();\n        enTitle = cleanTitleArtifacts(enTitle);\n        // Verify EN title doesn't contain non-English text (e.g. Spanish from LLM glitch)\n        const enChk = ' ' + enTitle.toLowerCase() + ' ';\n        const nonEnMk = [' und ', ' mit ', ' f\u00fcr ', ' der ', ' die ', ' con ', ' para ', ' del ', ' avec ', ' pour ', ' dans ', ' ze ', ' dla ', ' och ', ' med '];\n        const brandClean = enTitle.replace(data.brand || '', '');\n        if (nonEnMk.some(w => enChk.includes(w)) || /[\u0105\u0107\u0119\u0142\u0144\u00f3\u015b\u017a\u017c\u00e4\u00f6\u00fc\u00df\u00e0\u00e2\u00e9\u00e8\u00ea\u00eb\u00ef\u00f4\u00f9\u00fb\u00fc\u00ff\u00e7\u00e1\u00e9\u00ed\u00f3\u00fa\u00f1\u00e5\u00f6]/i.test(brandClean)) {\n          debugLog.push(`[${mp}] EN title has non-English content, retrying...`);\n          await sleep(DELAYS.between_translations);\n          const retryEn = await translateWithGroq('TRANSLATE TO ENGLISH: ' + enTitle, 'EN');\n          if (retryEn && retryEn.length > 10) {\n            enTitle = retryEn.replace(/^[\"']|[\"']$/g, '').trim();\n            enTitle = cleanTitleArtifacts(enTitle);\n            debugLog.push(`[${mp}] EN title retry applied`);\n          }\n        }\n        const baseMp = mp.startsWith('amazon') ? 'amazon' : mp;\n        const limits = TITLE_LIMITS[baseMp] || TITLE_LIMITS.amazon;\n        enTitle = extendTitle(enTitle, 'EN', limits.min, limits.max);\n        listings[mp].title = enTitle;\n        listings[mp].title_length = enTitle.length;\n        listings[mp].title_translated_to_en = true;\n        debugLog.push(`[${mp}] EN title: ${enTitle.length} chars`);\n      } catch (e) {\n        debugLog.push(`[${mp}] EN title translation failed: ${e.message}`);\n      }\n      await sleep(DELAYS.between_translations);\n    }\n  }\n  \n  // Fix Polish product name in EN market descriptions (from fallback templates)\n  const origProductName = data.title || '';\n  if (origProductName && looksNonEnglish(origProductName)) {\n    const escRx = (s) => s.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n    for (const mp of EN_MARKETS) {\n      if (listings[mp] && listings[mp].description) {\n        const desc = listings[mp].description;\n        if (desc.includes(origProductName) || desc.includes((data.brand || '') + ' ' + origProductName)) {\n          // Extract clean EN product name from translated title\n          let enName = listings[mp].title || '';\n          const brand = (data.brand || '').trim();\n          if (brand) enName = enName.replace(brand, '').trim();\n          for (const pw of (TITLE_PADDING.EN || [])) {\n            enName = enName.replace(new RegExp('\\\\s*' + escRx(pw) + '$', 'i'), '').trim();\n          }\n          if (enName.length > 3) {\n            const fullPL = brand ? (brand + ' ' + origProductName) : origProductName;\n            listings[mp].description = desc\n              .replace(new RegExp(escRx(fullPL), 'gi'), brand ? (brand + ' ' + enName) : enName)\n              .replace(new RegExp(escRx(origProductName), 'gi'), enName);\n            debugLog.push(`[${mp}] Replaced PL product name in EN description`);\n          }\n        }\n      }\n    }\n  }\n  \n  // Universal bullet cleanup for ALL marketplaces (catches meta-comments from both generation and translation)\n  for (const mp of Object.keys(listings)) {\n    if (listings[mp] && listings[mp].bullets) {\n      listings[mp].bullets = listings[mp].bullets\n        .map(b => cleanBulletArtifacts(b))\n        .filter(b => {\n          const stripped = b.replace(/\\*\\*/g, '').trim();\n          // Remove framework headers that slipped through\n          if (/^(BULLET\\s*\\d|MAIN\\s+USP|DIFFERENTIATOR|KEY\\s+(SELLING|FEATURE)|QUALITY|TRUST)/i.test(stripped)) return false;\n          if (/^[A-Z\\s\\/\\-\\>\u2192:]+$/.test(stripped) && stripped.length < 60) return false;\n          return stripped.length > 15;\n        });\n      // Ensure at least 3 bullets (keep originals if filter removed too many)\n      if (listings[mp].bullets.length < 3) {\n        listings[mp].bullets = ($input.first().json.listings?.[mp]?.bullets || listings[mp].bullets);\n      }\n    }\n  }\n  \n  // Pre-replace Polish product name in non-EN bullets that still contain it\n  const origPN = data.title || '';\n  if (origPN) {\n    const escPN = (s) => s.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n    for (const [mp, listing] of Object.entries(listings)) {\n      if (listing.translated && listing.language !== 'EN') {\n        const translatedName = listing.title.replace(data.brand || '', '').trim()\n          .replace(/\\s*(Premium|Professionell|Hochwertig|Langlebig|Erstklassig|Haute|Wysoka|Doskona\u0142y).*$/i, '').trim();\n        if (translatedName.length > 3) {\n          listing.bullets = listing.bullets.map(b =>\n            b.replace(new RegExp(escPN(origPN), 'gi'), translatedName)\n          );\n          listing.description = listing.description.replace(new RegExp(escPN(origPN), 'gi'), translatedName);\n        }\n      }\n    }\n  }\n  \n  debugLog.push(`Complete (used key #${currentKeyIndex + 1})`);\n  return [{ json: { ...data, listings, translationsApplied: true, debug: debugLog } }];\n} catch (error) {\n  debugLog.push(`ERROR: ${error.message}`);\n  return [{ json: { ...data, listings, translationsApplied: false, translateError: error.message, debug: debugLog } }];\n}"
      },
      "onError": "continueRegularOutput"
    },
    {
      "id": "format-response",
      "name": "Format Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1150,
        0
      ],
      "parameters": {
        "jsCode": "// Format Response - Final output with Forbidden Words Validation\nconst data = $input.first().json;\n\n// Safe access with defaults\nconst title = data.title || 'Product';\nconst description = data.description || '';\nconst brand = data.brand || '';\nconst listings = data.listings || {};\nconst marketplaces = data.marketplaces || Object.keys(listings);\nconst keywordStats = data.keywordStats || null;\nconst hasKeywordFile = data.hasKeywordFile || false;\n\n// Get keywords array (from Process Input)\nconst keywordsArray = data.keywords || [];\n\n// === FORBIDDEN WORDS VALIDATION ===\nconst RULES = [\n  // PROMOTIONAL CTA\n  { id: 'promo_buy_now_en', pattern: '\\\\b(buy now|shop now|order now|order today|add to cart|click here|act now|limited time)\\\\b', marketplaces: ['amazon_us', 'amazon_uk', 'ebay', 'etsy'], severity: 'block', category: 'promotional_cta', suggestion: 'Remove CTA phrases' },\n  { id: 'promo_buy_now_de', pattern: '\\\\b(jetzt kaufen|jetzt bestellen|in den warenkorb|nicht verpassen|begrenzte zeit)\\\\b', marketplaces: ['amazon_de'], severity: 'block', category: 'promotional_cta', suggestion: 'CTA-Phrasen entfernen' },\n  { id: 'promo_buy_now_pl', pattern: '\\\\b(kup teraz|zam\u00f3w teraz|dodaj do koszyka|nie przegap|tylko teraz)\\\\b', marketplaces: ['amazon_pl', 'allegro'], severity: 'block', category: 'promotional_cta', suggestion: 'Usu\u0144 CTA' },\n  \n  // PRICING\n  { id: 'pricing_en', pattern: '\\\\b(best deal|best price|cheapest|lowest price|save money|discount|sale|on sale|free shipping)\\\\b', marketplaces: ['amazon_us', 'amazon_uk', 'ebay'], severity: 'block', category: 'pricing_claims', suggestion: 'Remove pricing language' },\n  { id: 'pricing_de', pattern: '\\\\b(bester preis|billigste|g\u00fcnstigste|sparen sie|rabatt|ausverkauf|kostenloser versand)\\\\b', marketplaces: ['amazon_de'], severity: 'block', category: 'pricing_claims', suggestion: 'Preissprache entfernen' },\n  { id: 'pricing_pl', pattern: '\\\\b(najlepsza cena|najtaniej|oszcz\u0119d\u017a|rabat|promocja|wyprzeda\u017c|darmowa wysy\u0142ka)\\\\b', marketplaces: ['amazon_pl', 'allegro'], severity: 'block', category: 'pricing_claims', suggestion: 'Usu\u0144 j\u0119zyk cenowy' },\n  \n  // SUPERLATIVES\n  { id: 'super_en', pattern: '\\\\b(best|#1|number one|top rated|award winning|most popular|leading|ultimate)\\\\b', marketplaces: ['amazon_us', 'amazon_uk', 'ebay'], severity: 'warning', category: 'superlatives', suggestion: 'Use premium or professional-grade', replacement: 'premium' },\n  { id: 'super_de', pattern: '\\\\b(beste|bester|nummer eins|top bewertet|preisgekr\u00f6nt|beliebteste|f\u00fchrend)\\\\b', marketplaces: ['amazon_de'], severity: 'warning', category: 'superlatives', suggestion: 'Verwenden Sie Premium', replacement: 'Premium' },\n  { id: 'super_pl', pattern: '\\\\b(najlepszy|najlepsza|numer jeden|najwy\u017cej oceniany|najpopularniejszy)\\\\b', marketplaces: ['amazon_pl', 'allegro'], severity: 'warning', category: 'superlatives', suggestion: 'U\u017cyj premium', replacement: 'premium' },\n  \n  // MEDICAL\n  { id: 'medical_en', pattern: '\\\\b(cure[sd]?|heal[sd]?|treat[sd]?|prevent[sd]?|therapeutic|antibacterial|antiviral)\\\\b', marketplaces: ['amazon_us', 'amazon_uk', 'ebay'], severity: 'block', category: 'medical_claims', suggestion: 'Use supports, helps with, promotes' },\n  { id: 'medical_de', pattern: '\\\\b(heilt|heilend|behandelt|verhindert|therapeutisch|antibakteriell)\\\\b', marketplaces: ['amazon_de'], severity: 'block', category: 'medical_claims', suggestion: 'Verwenden Sie unterst\u00fctzt, f\u00f6rdert' },\n  { id: 'medical_pl', pattern: '\\\\b(leczy|leczniczy|terapeutyczny|zapobiega|antybakteryjny)\\\\b', marketplaces: ['amazon_pl', 'allegro'], severity: 'block', category: 'medical_claims', suggestion: 'U\u017cyj wspiera, pomaga' },\n  \n  // DISEASES\n  { id: 'diseases', pattern: '\\\\b(cancer|diabetes|alzheimer|depression|anxiety|covid|coronavirus|disease)\\\\b', marketplaces: ['amazon_us', 'amazon_uk', 'amazon_de'], severity: 'block', category: 'medical_diseases', suggestion: 'Disease names prohibited' },\n  \n  // ECO/BIO (EU strict)\n  { id: 'eco_de', pattern: '\\\\b(bio|\u00f6ko|\u00f6kologisch|biologisch|organic)\\\\b', marketplaces: ['amazon_de'], severity: 'block', category: 'eco_certification', suggestion: 'Requires EU cert - use nat\u00fcrlich', replacement: 'nat\u00fcrlich' },\n  { id: 'eco_eu', pattern: '\\\\b(organic|eco-friendly|sustainable)\\\\b', marketplaces: ['amazon_uk', 'amazon_fr', 'amazon_it', 'amazon_es'], severity: 'warning', category: 'eco_certification', suggestion: 'May require EU certification' },\n  \n  // AMAZON TRADEMARK\n  { id: 'amazon_tm', pattern: '\\\\b(amazon\\'?s choice|amazon prime|prime eligible|best seller badge)\\\\b', marketplaces: ['amazon_us', 'amazon_uk', 'amazon_de', 'amazon_pl'], severity: 'block', category: 'amazon_trademark', suggestion: 'Only Amazon can assign badges' },\n  \n  // REVIEWS\n  { id: 'reviews', pattern: '\\\\b(5-?star|five star|highly rated|top reviewed|customer favorite)\\\\b', marketplaces: ['amazon_us', 'amazon_uk'], severity: 'block', category: 'review_manipulation', suggestion: 'Review references prohibited' },\n  \n  // URGENCY\n  { id: 'urgency_en', pattern: '\\\\b(limited stock|while supplies last|selling fast|almost gone|last chance|hurry|act fast)\\\\b', marketplaces: ['amazon_us', 'amazon_uk', 'ebay'], severity: 'block', category: 'urgency', suggestion: 'Urgency language prohibited' },\n  { id: 'urgency_de', pattern: '\\\\b(begrenzter vorrat|solange vorrat reicht|letzte chance|beeilen)\\\\b', marketplaces: ['amazon_de'], severity: 'block', category: 'urgency', suggestion: 'Dringlichkeit verboten' },\n  { id: 'urgency_pl', pattern: '\\\\b(ograniczona ilo\u015b\u0107|do wyczerpania|ostatnia szansa|pospiesz si\u0119)\\\\b', marketplaces: ['amazon_pl', 'allegro'], severity: 'block', category: 'urgency', suggestion: 'Pilno\u015b\u0107 zabroniona' },\n  \n  // COUNTERFEIT\n  { id: 'counterfeit', pattern: '\\\\b(replica|knockoff|imitation|fake|counterfeit|inspired by|dupe)\\\\b', marketplaces: ['all'], severity: 'block', category: 'counterfeit', suggestion: 'Counterfeit language prohibited' },\n  \n  // SAFETY (warning)\n  { id: 'safety', pattern: '\\\\b(safe for children|child-?safe|non-?toxic|bpa-?free|fda approved|clinically proven)\\\\b', marketplaces: ['amazon_us', 'amazon_uk'], severity: 'warning', category: 'safety_claims', suggestion: 'Verify certification exists' },\n  \n  // GUARANTEE\n  { id: 'guarantee', pattern: '\\\\b(100% guaranteed|lifetime guarantee|money-?back|satisfaction guaranteed|risk-?free)\\\\b', marketplaces: ['amazon_us', 'amazon_uk', 'ebay'], severity: 'warning', category: 'guarantee', suggestion: 'Ensure matches your policy' }\n];\n\nfunction validateListing(mp, listing) {\n  const violations = [];\n  const content = [listing.title || '', ...(listing.bullets || []), listing.description || ''].join(' ').toLowerCase();\n  const rules = RULES.filter(r => r.marketplaces.includes('all') || r.marketplaces.includes(mp));\n  \n  for (const rule of rules) {\n    try {\n      const regex = new RegExp(rule.pattern, 'gi');\n      const matches = content.match(regex);\n      if (matches) {\n        let loc = 'content';\n        if ((listing.title || '').toLowerCase().match(regex)) loc = 'title';\n        else if ((listing.bullets || []).some(b => b.toLowerCase().match(regex))) loc = 'bullets';\n        else if ((listing.description || '').toLowerCase().match(regex)) loc = 'description';\n        \n        violations.push({\n          ruleId: rule.id, category: rule.category, severity: rule.severity,\n          matches: [...new Set(matches.map(m => m.toLowerCase()))], location: loc,\n          suggestion: rule.suggestion, replacement: rule.replacement || null,\n          autoFixAvailable: !!rule.replacement\n        });\n      }\n    } catch (e) { /* skip invalid regex */ }\n  }\n  return violations;\n}\n\n// Validate all listings\nconst policyViolations = {};\nlet totalViolations = 0, blockCount = 0, warningCount = 0;\n\nfor (const [mp, listing] of Object.entries(listings)) {\n  const v = validateListing(mp, listing);\n  policyViolations[mp] = v;\n  totalViolations += v.length;\n  blockCount += v.filter(x => x.severity === 'block').length;\n  warningCount += v.filter(x => x.severity === 'warning').length;\n  console.log(`${mp}: ${v.length} violations (${v.filter(x => x.severity === 'block').length} blocks)`);\n}\n\n// Calculate quality score with keyword bonus\nlet qualityScore = 75;\nif (title.length > 50) qualityScore += 5;\nif (description.length > 100) qualityScore += 5;\nif (brand) qualityScore += 5;\nif (hasKeywordFile) { qualityScore += 10; if (keywordStats?.total_uploaded > 20) qualityScore += 5; }\nif (blockCount > 0) qualityScore -= (blockCount * 10); // Penalty for blocks\nqualityScore = Math.max(0, Math.min(100, qualityScore));\n\nconst qualityGrade = qualityScore >= 95 ? 'A+' : qualityScore >= 90 ? 'A' : qualityScore >= 80 ? 'B+' : qualityScore >= 70 ? 'B' : qualityScore >= 50 ? 'C' : 'F';\n\nconst keywordsUsed = hasKeywordFile ? {\n  source: keywordStats?.source || data.keywordSource || 'unknown',\n  total_uploaded: keywordStats?.total_uploaded || data.keywordCount || keywordsArray.length,\n  integrated_in_bullets: true\n} : null;\n\nreturn [{\n  json: {\n    success: blockCount === 0,\n    product_id: 'prod_' + Date.now(),\n    sku: data.sku || 'SKU-001',\n    ai_generation: {\n      quality_score: qualityScore,\n      quality_grade: qualityGrade,\n      expert_enhanced: true,\n      keyword_research_used: hasKeywordFile,\n      translations_applied: data.translationsApplied || false,\n      title_lengths: Object.fromEntries(Object.entries(listings).map(([mp, l]) => [mp, l?.title_length || 0]))\n    },\n    policy_validation: {\n      passed: blockCount === 0,\n      total_violations: totalViolations,\n      blocks: blockCount,\n      warnings: warningCount,\n      violations_by_marketplace: policyViolations\n    },\n    keywords_used: keywordsUsed,\n    marketplaces: marketplaces,\n    listings: listings,\n    keywordData: keywordsArray,\n    generated_at: data.generatedAt || new Date().toISOString()\n  }\n}];"
      }
    },
    {
      "id": "101d08c3-0e7b-42ae-9d5e-175c9e77818d",
      "name": "Error Trigger",
      "type": "n8n-nodes-base.errorTrigger",
      "typeVersion": 1,
      "position": [
        0,
        250
      ],
      "parameters": {}
    },
    {
      "id": "2f62ffa7-55ba-4f96-8d66-d57800c3cece",
      "name": "Store Error to n8n Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        200,
        250
      ],
      "parameters": {
        "jsCode": "// Store errors in n8n's built-in static data storage\nconst error = $input.first().json;\n\n// Get persistent storage\nconst staticData = $getWorkflowStaticData('global');\n\n// Initialize error log array if not exists\nif (!staticData.errorLog) {\n  staticData.errorLog = [];\n}\n\n// Create error entry\nconst errorEntry = {\n  id: 'err_' + Date.now(),\n  timestamp: new Date().toISOString(),\n  workflow: 'Multi-Marketplace Generator v2',\n  error_message: error.execution?.error?.message || 'Unknown error',\n  error_node: error.execution?.error?.node?.name || 'Unknown node',\n  error_type: error.execution?.error?.name || 'Error',\n  execution_id: error.execution?.id || 'N/A',\n  execution_mode: error.execution?.mode || 'N/A',\n  input_data: error.execution?.data?.resultData?.runData || null\n};\n\n// Add to log (keep last 50 errors)\nstaticData.errorLog.unshift(errorEntry);\nif (staticData.errorLog.length > 50) {\n  staticData.errorLog = staticData.errorLog.slice(0, 50);\n}\n\n// Update stats\nstaticData.errorStats = staticData.errorStats || { total: 0, lastError: null };\nstaticData.errorStats.total++;\nstaticData.errorStats.lastError = errorEntry.timestamp;\n\nconsole.log('Error stored:', errorEntry.id);\n\nreturn [{ json: { stored: true, error_id: errorEntry.id, total_errors: staticData.errorStats.total } }];"
      }
    },
    {
      "id": "453a60f7-413d-48ab-9984-9143959af207",
      "name": "Webhook Errors",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        0,
        450
      ],
      "parameters": {
        "path": "v2/errors",
        "httpMethod": "GET",
        "responseMode": "lastNode",
        "options": {
          "responseCode": 200
        }
      },
      "webhookId": "v2-errors"
    },
    {
      "id": "f1464cd0-d210-46c7-8a09-6c7bc90c9a3b",
      "name": "Get Error Logs",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        200,
        450
      ],
      "parameters": {
        "jsCode": "// Read error logs from n8n static data storage\nconst staticData = $getWorkflowStaticData('global');\n\nconst errorLog = staticData.errorLog || [];\nconst errorStats = staticData.errorStats || { total: 0, lastError: null };\n\n// Get query params for filtering\nconst query = $input.first().json.query || {};\nconst limit = parseInt(query.limit) || 10;\nconst nodeFilter = query.node || null;\n\n// Filter and limit results\nlet filteredLogs = errorLog;\nif (nodeFilter) {\n  filteredLogs = errorLog.filter(e => e.error_node?.toLowerCase().includes(nodeFilter.toLowerCase()));\n}\nfilteredLogs = filteredLogs.slice(0, limit);\n\nreturn [{\n  json: {\n    success: true,\n    stats: {\n      total_errors: errorStats.total,\n      last_error: errorStats.lastError,\n      stored_count: errorLog.length\n    },\n    filters: {\n      limit,\n      node: nodeFilter\n    },\n    errors: filteredLogs\n  }\n}];"
      }
    },
    {
      "id": "ss-keyword-analysis",
      "name": "SS Keyword Analysis",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1325,
        0
      ],
      "parameters": {
        "jsCode": "// SS Keyword Analysis - Seller Systems Intelligence\n// location: n8n workflow node\n// Purpose: Analyze keywords and generate SS Intelligence data\n// NOT for: Content generation (that's done by Groq nodes)\n\nconst input = $input.first().json;\nconst listings = input.listings || {};\nconst keywordData = input.keywordData || [];\nconst marketplaces = input.marketplaces || [];\n\n// 1. KEYWORD PRIORITY TABLE with Title Density calculation\nconst calculateTitleDensity = (keyword, listings) => {\n  let inTitleCount = 0;\n  let totalMarketplaces = Object.keys(listings).length;\n  \n  for (const [mp, listing] of Object.entries(listings)) {\n    const title = (listing.title || '').toLowerCase();\n    if (title.includes(keyword.toLowerCase())) {\n      inTitleCount++;\n    }\n  }\n  \n  return totalMarketplaces > 0 ? Math.round((inTitleCount / totalMarketplaces) * 100) : 0;\n};\n\nconst keywordPriorityTable = keywordData.map(kw => ({\n  phrase: kw.phrase,\n  searchVolume: kw.searchVolume || 0,\n  rankingJuice: kw.rankingJuice || 0,\n  relevancy: kw.relevancy || 0,\n  priorityScore: kw.priority || (kw.searchVolume * kw.relevancy * 0.01),\n  titleDensity: calculateTitleDensity(kw.phrase, listings),\n  recommendation: kw.searchVolume > 10000 ? 'PRIMARY_TITLE' : \n                 kw.searchVolume > 5000 ? 'SECONDARY_TITLE' : \n                 kw.searchVolume > 2000 ? 'BULLETS' : 'BACKEND'\n})).sort((a, b) => b.priorityScore - a.priorityScore);\n\n// 2. KEYWORD PLACEMENT MAP\nconst analyzeKeywordPlacement = (keyword, listing) => {\n  const kw = keyword.toLowerCase();\n  const placements = [];\n  if ((listing.title || '').toLowerCase().includes(kw)) placements.push('title');\n  (listing.bullets || []).forEach((bullet, idx) => {\n    if (bullet.toLowerCase().includes(kw)) placements.push(`bullet_${idx + 1}`);\n  });\n  if ((listing.description || '').toLowerCase().includes(kw)) placements.push('description');\n  if ((listing.backend_keywords || '').toLowerCase().includes(kw)) placements.push('backend');\n  return placements;\n};\n\nconst keywordPlacementMap = {};\nfor (const [mp, listing] of Object.entries(listings)) {\n  keywordPlacementMap[mp] = {};\n  for (const kw of keywordData) {\n    keywordPlacementMap[mp][kw.phrase] = analyzeKeywordPlacement(kw.phrase, listing);\n  }\n}\n\n// 3. REBUILT LISTING SUGGESTIONS\nconst top3Keywords = keywordPriorityTable.slice(0, 3);\nconst rebuiltSuggestions = {\n  title_optimization: {\n    current_keywords_in_title: top3Keywords.filter(kw => kw.titleDensity > 0).map(kw => kw.phrase),\n    missing_high_priority: top3Keywords.filter(kw => kw.titleDensity === 0).map(kw => kw.phrase),\n    suggested_title_structure: `[Brand] ${top3Keywords[0]?.phrase || ''} - ${top3Keywords[1]?.phrase || ''} | ${top3Keywords[2]?.phrase || ''}`\n  },\n  bullet_optimization: {\n    primary_keyword_bullets: keywordPriorityTable.slice(0, 5).map((kw, idx) => ({\n      bullet_number: idx + 1,\n      target_keyword: kw.phrase,\n      search_volume: kw.searchVolume\n    }))\n  },\n  backend_keywords: {\n    not_in_frontend: keywordData.filter(kw => {\n      const usListing = listings.amazon_us || listings[Object.keys(listings)[0]] || {};\n      const title = (usListing.title || '').toLowerCase();\n      const bullets = (usListing.bullets || []).join(' ').toLowerCase();\n      return !title.includes(kw.phrase.toLowerCase()) && !bullets.includes(kw.phrase.toLowerCase());\n    }).map(kw => kw.phrase).slice(0, 10)\n  }\n};\n\n// 4. STRATEGY RECOMMENDATIONS\nconst totalSearchVolume = keywordData.reduce((sum, kw) => sum + (kw.searchVolume || 0), 0);\nconst avgRankingJuice = keywordData.length > 0 \n  ? keywordData.reduce((sum, kw) => sum + (kw.rankingJuice || 0), 0) / keywordData.length \n  : 0;\n\nconst strategyRecommendations = {\n  market_analysis: {\n    total_search_volume: totalSearchVolume,\n    avg_ranking_juice: Math.round(avgRankingJuice),\n    competition_level: avgRankingJuice > 80000 ? 'HIGH' : avgRankingJuice > 50000 ? 'MEDIUM' : 'LOW',\n    market_opportunity: totalSearchVolume > 50000 ? 'STRONG' : totalSearchVolume > 20000 ? 'MODERATE' : 'NICHE'\n  },\n  ppc_strategy: {\n    phase_1_exact_match: {\n      keywords: top3Keywords.map(kw => kw.phrase),\n      bid_strategy: 'Start high ($1.50-2.00), Top of Search 900% multiplier',\n      goal: 'Establish ranking on primary keywords'\n    },\n    phase_2_expansion: {\n      keywords: keywordPriorityTable.slice(3, 8).map(kw => kw.phrase),\n      bid_strategy: 'Phrase match, moderate bids ($0.80-1.20)',\n      goal: 'Capture long-tail traffic'\n    },\n    phase_3_auto: {\n      strategy: 'Auto campaign catch-all with low bid ($0.10-0.15)',\n      goal: 'Discover new converting keywords'\n    }\n  },\n  organic_strategy: {\n    title_priority: 'Include TOP 2 keywords with highest search volume',\n    bullet_strategy: 'One primary keyword per bullet, CAPS for emphasis',\n    indexing_check: 'Verify indexing with Brand Analytics after 48h',\n    honeymoon_period: 'First 14 days critical - maximize sales velocity'\n  }\n};\n\nconst ssIntelligence = {\n  keyword_priority_table: keywordPriorityTable,\n  keyword_placement_map: keywordPlacementMap,\n  rebuilt_suggestions: rebuiltSuggestions,\n  strategy_recommendations: strategyRecommendations,\n  analysis_timestamp: new Date().toISOString()\n};\n\n// FIXED: Return array of objects with json property (n8n requirement)\nreturn [{ json: { ...input, ss_intelligence: ssIntelligence }}];"
      }
    },
    {
      "id": "ss-knowledge-base",
      "name": "SS Knowledge Base",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        275,
        0
      ],
      "parameters": {
        "jsCode": "// SS Knowledge Base - SellerSystems Inner Circle Expert Knowledge\n// Purpose: Provide structured Amazon listing optimization knowledge to AI prompts\n// Source: Compiled from 194 SellerSystems transcripts (Inner Circle 2022-2025)\n// NOT for: Direct user output - this feeds downstream Groq prompts\n\nconst input = $input.first().json;\n\n// === BULLET POINTS KNOWLEDGE ===\nconst bulletsKnowledge = `SELLERSYSTEMS INNER CIRCLE - BULLET POINT MASTERY:\n\nRANKING JUICE HIERARCHY (CRITICAL - determines indexing power):\n1. TITLE - exact match keywords get MOST ranking credit (position matters: front = more weight)\n2. BULLET POINTS - second most important, top bullets weighted more than bottom\n3. BACKEND KEYWORDS - third level (indexing only, zero direct ranking weight)\n4. DESCRIPTION - lowest weight but still indexes\n5. A+ CONTENT - does NOT index for keywords at all\n\nMANDATORY 5-BULLET STRUCTURE:\nBullet 1: Main USP/differentiator - Why THIS product beats every competitor\nBullet 2: Primary feature converted to customer benefit (feature -> so what -> why care)\nBullet 3: Quality/materials/construction that builds trust and justifies price\nBullet 4: Versatility/use cases that expand perceived value (multiple scenarios)\nBullet 5: Risk reversal/guarantee/customer service promise\n\nBULLET FORMAT RULES:\n- Start with CAPITAL BENEFIT HEADER (2-3 words) followed by dash\n- Format: [CAPS HEADER] - [Feature explanation -> benefit -> how it helps customer]\n- Length: 200-250 characters per bullet (CRITICAL: mobile shows first ~150 chars, front-load benefits!)\n- Each bullet must target a DIFFERENT customer avatar\n- Include secondary keywords NATURALLY (forced keywords hurt conversion)\n- Keywords in BOTH title AND bullets = double ranking credit\n\nPOWER HEADER WORDS: PREMIUM QUALITY, PROFESSIONAL GRADE, VERSATILE DESIGN, DURABLE CONSTRUCTION, EASY TO USE, SATISFACTION GUARANTEED, QUICK SETUP, ALL-IN-ONE\n\nCUSTOMER AVATAR TARGETING (address 3-4 per listing):\n- Eco-Conscious Buyer: sustainability, natural materials, eco-friendly\n- Busy Professional/Parent: efficiency, time-saving, quick setup\n- Budget-Conscious: value for money, durability, long-lasting\n- Gift Shopper: presentation, thoughtfulness, premium packaging\n- Health-Conscious: safety, non-toxic, certifications\n- Minimalist/Design: clean aesthetics, quality over quantity\n- Enthusiast/Hobbyist: technical specs, performance details`;\n\n// === DESCRIPTION KNOWLEDGE ===\nconst descriptionKnowledge = `SELLERSYSTEMS - DESCRIPTION OPTIMIZATION:\n\nDESCRIPTION RANKING WEIGHT: Lowest of all indexable sections, but STILL INDEXES.\nKEY STRATEGY: Include keywords NOT already used in title and bullets to MAXIMIZE root word coverage.\n\nA9 ALGORITHM TARGETING (3 layers):\n1. LEXICAL (exact keywords) - include remaining exact-match phrases\n2. SEMANTIC (BERT model) - use synonyms, related terms, contextual language\n3. BEHAVIORAL (COSMO) - describe use cases that match how customers search\n\nSTRUCTURE: 3 paragraphs:\nParagraph 1: Lifestyle hook - paint picture of customer using product\nParagraph 2: Core value proposition - what makes this product special\nParagraph 3: Trust & close - brand promise, quality assurance\n\nRULES:\n- 150-200 words, 2-3 paragraphs\n- Professional tone, NO hype words, NO emojis\n- Focus on REMAINING keywords (ones NOT in title/bullets)\n- Include complementary use-case keywords and long-tail variations\n- Do NOT repeat keywords already heavily used in title\n- Address customer avatars NOT covered in bullets`;\n\n// === KEYWORD & ROOT WORD KNOWLEDGE ===\nconst keywordKnowledge = `SELLERSYSTEMS - KEYWORD & ROOT WORD STRATEGY:\n\nROOT WORD CONCEPT (FUNDAMENTAL):\n- Root words = base components of keyword phrases\n- Example: \"wireless bluetooth headphones\" roots: wireless, bluetooth, headphones\n- Ranking for ONE keyword gives credit to ALL related root keywords\n- EVERY root word must appear SOMEWHERE in the listing (no holes = no missed rankings)\n\nIMPLEMENTATION PRIORITY:\n1. Title (first 150 chars) = most important roots as EXACT MATCH phrases\n2. Bullets = secondary roots woven naturally into benefit statements\n3. Backend = ALL remaining roots not covered elsewhere\n4. Description = long-tail variations and semantic keywords\n\nTITLE OPTIMIZATION:\n- 200 char max, but PRIORITIZE first 150 chars (highest indexing weight)\n- Structure: [Brand] [Primary Keyword] - [Secondary KW] [Size/Qty] [Key Feature]\n- Put HIGHEST SEARCH VOLUME keyword at front of title\n- Use dashes (-) to separate keyword phrases (helps Amazon parse)\n- Exact match in title > phrase match > broad match for ranking\n\nBACKEND KEYWORDS:\n- 250 bytes limit (NOT characters - special chars = more bytes)\n- Space-separated, NO commas needed\n- NO plurals (Amazon handles singular/plural automatically)\n- NO brand names (yours or competitors - violation risk)\n- Include: misspellings, synonyms, use cases, materials, occasions, Spanish terms\n\nQUALITY CHECKLIST:\n[ ] All root words covered somewhere in listing\n[ ] Main keyword in first 150 chars of title  \n[ ] 5 bullets, each 200-250 chars, CAPS header\n[ ] No keyword repetition across sections (wastes indexing)\n[ ] Mobile-friendly (front-loaded benefits in bullets)\n[ ] Addresses 3+ customer avatars\n[ ] Natural readable language (not keyword-stuffed)`;\n\n// === MARKETPLACE-SPECIFIC RULES ===\nconst marketplaceKnowledge = `MARKETPLACE-SPECIFIC OPTIMIZATION:\n\nAMAZON US: 200 char title, 5 bullets, English, benefits > features, A9 algorithm\nAMAZON DE: German language, 200 char, formal tone, precision/quality valued\nAMAZON PL: Polish REQUIRED, price-sensitive, formal, trust/quality emphasis\nALLEGRO: Polish REQUIRED, max 50 char title, price-conscious, Cassini-like algo, trust badges important\nEBAY: Cassini algorithm (NOT A9), item specifics CRITICAL for ranking, 80 char optimal title, condition important\nETSY: Storytelling approach, 13 tags required, handmade/craft emphasis, warm emotional tone`;\n\nreturn [{\n  json: {\n    ...input,\n    ss_knowledge: {\n      bullets: bulletsKnowledge,\n      description: descriptionKnowledge,\n      keywords: keywordKnowledge,\n      marketplace: marketplaceKnowledge\n    }\n  }\n}];\n"
      }
    }
  ],
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "Process Input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Input": {
      "main": [
        [
          {
            "node": "SS Knowledge Base",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Groq Generate Bullets": {
      "main": [
        [
          {
            "node": "Groq Generate Description",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Groq Generate Description": {
      "main": [
        [
          {
            "node": "Generate Listings",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Listings": {
      "main": [
        [
          {
            "node": "Groq Translate EU",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Groq Translate EU": {
      "main": [
        [
          {
            "node": "Format Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Error Trigger": {
      "main": [
        [
          {
            "node": "Store Error to n8n Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Webhook Errors": {
      "main": [
        [
          {
            "node": "Get Error Logs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Response": {
      "main": [
        [
          {
            "node": "SS Keyword Analysis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "SS Knowledge Base": {
      "main": [
        [
          {
            "node": "Groq Generate Bullets",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "saveDataErrorExecution": "all",
    "saveDataSuccessExecution": "all",
    "saveManualExecutions": true,
    "saveExecutionProgress": true,
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": true,
    "errorWorkflow": "RlF4sS5Enms49b8L"
  },
  "staticData": null,
  "meta": null,
  "pinData": null,
  "versionId": "9a77613e-48bb-4dd8-9c67-c8a635165b8b",
  "activeVersionId": "9a77613e-48bb-4dd8-9c67-c8a635165b8b",
  "versionCounter": 131,
  "triggerCount": 2,
  "shared": [
    {
      "updatedAt": "2026-01-16T14:12:43.405Z",
      "createdAt": "2026-01-16T14:12:43.405Z",
      "role": "workflow:owner",
      "workflowId": "DkudCZWTD4TI1FRE",
      "projectId": "JvOVZHRp5aEgSSMl",
      "project": {
        "updatedAt": "2026-01-04T13:04:18.280Z",
        "createdAt": "2026-01-04T13:02:09.054Z",
        "id": "JvOVZHRp5aEgSSMl",
        "name": "Shawn Mikrus <guciosells@gmail.com>",
        "type": "personal",
        "icon": null,
        "description": null,
        "creatorId": "f0c5c8ed-f6c8-448b-b198-045018831ce5",
        "projectRelations": [
          {
            "updatedAt": "2026-01-04T13:02:09.054Z",
            "createdAt": "2026-01-04T13:02:09.054Z",
            "userId": "f0c5c8ed-f6c8-448b-b198-045018831ce5",
            "projectId": "JvOVZHRp5aEgSSMl",
            "user": {
              "updatedAt": "2026-02-03T08:01:43.000Z",
              "createdAt": "2026-01-04T13:02:07.182Z",
              "id": "f0c5c8ed-f6c8-448b-b198-045018831ce5",
              "email": "guciosells@gmail.com",
              "firstName": "Shawn",
              "lastName": "Mikrus",
              "personalizationAnswers": {
                "version": "v4",
                "personalization_survey_submitted_at": "2026-01-04T13:04:49.457Z",
                "personalization_survey_n8n_version": "2.1.5"
              },
              "settings": {
                "userActivated": true,
                "firstSuccessfulWorkflowId": "fej0sn5wNqnaqW90",
                "userActivatedAt": 1767544556563,
                "easyAIWorkflowOnboarded": true,
                "npsSurvey": {
                  "responded": true,
                  "lastShownAt": 1769335750450
                }
              },
              "disabled": false,
              "mfaEnabled": false,
              "lastActiveAt": "2026-02-03",
              "isPending": false
            }
          }
        ]
      }
    }
  ],
  "tags": [],
  "activeVersion": {
    "updatedAt": "2026-02-03T18:47:19.571Z",
    "createdAt": "2026-02-03T18:47:19.571Z",
    "versionId": "9a77613e-48bb-4dd8-9c67-c8a635165b8b",
    "workflowId": "DkudCZWTD4TI1FRE",
    "nodes": [
      {
        "id": "webhook",
        "name": "Webhook",
        "type": "n8n-nodes-base.webhook",
        "typeVersion": 2,
        "position": [
          0,
          0
        ],
        "parameters": {
          "path": "v2/product",
          "httpMethod": "POST",
          "responseMode": "lastNode",
          "options": {
            "responseCode": 200
          }
        },
        "webhookId": "v2-product"
      },
      {
        "id": "process-input",
        "name": "Process Input",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          200,
          0
        ],
        "parameters": {
          "jsCode": "// Process Input v2.1 - Auth + Keyword File + Validation\n// ADDED: Marketplace whitelist, prompt injection sanitization\n// Updated: 2026-02-03\nconst input = $input.first().json;\n\n// === AUTHENTICATION ===\nconst WEBHOOK_API_KEY = 'WEBHOOK_API_KEY_REDACTED';\nconst providedKey = input.headers?.['x-api-key'] || input.headers?.['X-API-Key'];\n\nif (!providedKey) {\n  throw new Error('Unauthorized: Missing X-API-Key header');\n}\n\nif (providedKey !== WEBHOOK_API_KEY) {\n  throw new Error('Unauthorized: Invalid API key');\n}\n\nconsole.log('API Key authenticated');\n\n// === MARKETPLACE WHITELIST (reject unknown marketplaces) ===\nconst VALID_MARKETPLACES = [\n  'amazon_us', 'amazon_uk', 'amazon_de', 'amazon_fr', 'amazon_it',\n  'amazon_es', 'amazon_nl', 'amazon_se', 'amazon_pl',\n  'ebay', 'etsy', 'allegro'\n];\n\n// Sanitize text input to prevent prompt injection\n// Strips control sequences and trims excessive length\nconst sanitizeInput = (text, maxLen = 500) => {\n  if (!text || typeof text !== 'string') return text;\n  return text\n    .replace(/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F]/g, '') // strip control chars\n    .replace(/ignore\\s+(all\\s+)?(previous|above|prior)\\s+(instructions?|prompts?)/gi, '') // strip injection attempts\n    .replace(/system\\s*prompt/gi, '')\n    .trim()\n    .slice(0, maxLen);\n};\n\n// === TEST ERROR FLAG ===\nif (input.body?.test_error || input.test_error) {\n  throw new Error('TEST ERROR: Deliberate error triggered via test_error flag');\n}\n\n// === PROCESS PRODUCT DATA ===\n// Support both nested (body.product.title) and flat (body.title) structures\nconst body = input.body || {};\nconst product = body.product || body;\n\nconst title = sanitizeInput(product.title || product.productLine || product.name || 'Product', 300);\nconst brand = sanitizeInput(product.brand || 'Brand', 100);\nconst description = sanitizeInput(product.description || title, 1000);\nconst price = product.price || '29.99';\nconst sku = product.sku || 'SKU-001';\nconst category = product.category || 'General';\n\n// FIX: Accept marketplaces from BOTH root level AND product level\n// Priority: product.marketplaces > body.marketplaces > root level > default\nconst marketplaces = product.target_marketplaces || product.marketplaces || product.marketplace || body.marketplaces || body.marketplace || ['amazon_us'];\nconst specs = product.specifications || {};\n\n// Filter out invalid marketplace names\nconst validatedMarketplaces = (Array.isArray(marketplaces) ? marketplaces : [marketplaces])\n  .filter(mp => VALID_MARKETPLACES.includes(mp.toLowerCase()));\nif (validatedMarketplaces.length === 0) {\n  console.log('Warning: No valid marketplaces found, defaulting to amazon_us');\n}\nconst finalMarketplaces = validatedMarketplaces.length > 0 ? validatedMarketplaces : ['amazon_us'];\n\nconsole.log('Product: ' + title + ' by ' + brand);\nconsole.log('Marketplaces (raw): ' + (Array.isArray(marketplaces) ? marketplaces.join(', ') : marketplaces));\nconsole.log('Marketplaces (valid): ' + finalMarketplaces.join(', '));\n\n// === PROCESS KEYWORD DATA ===\nlet keywords = [];\nlet keywordSource = null;\nlet keywordCount = 0;\n\n// Try keywordFile format first\nconst keywordFile = product.keywordFile || body.keywordFile || null;\nif (keywordFile && keywordFile.data && Array.isArray(keywordFile.data)) {\n  keywordSource = keywordFile.source || 'structured_file';\n  keywords = keywordFile.data\n    .filter(kw => kw.phrase && kw.phrase.length > 0)\n    .sort((a, b) => (b.priority || 0) - (a.priority || 0))\n    .slice(0, 100);\n  keywordCount = keywordFile.keywordCount || keywords.length;\n  console.log('Loaded ' + keywords.length + ' keywords from keywordFile');\n}\n\n// Try keywordData format (direct API array)\nif (keywords.length === 0) {\n  const keywordData = product.keywordData || body.keywordData || [];\n  if (Array.isArray(keywordData) && keywordData.length > 0) {\n    keywordSource = 'datadive_mkl';\n    keywords = keywordData\n      .filter(kw => kw.phrase && kw.phrase.length > 0)\n      .sort((a, b) => (b.priority || b.searchVolume || 0) - (a.priority || a.searchVolume || 0))\n      .slice(0, 100);\n    keywordCount = keywords.length;\n    console.log('Loaded ' + keywords.length + ' keywords from keywordData');\n  }\n}\n\n// Try simple keywords array\nif (keywords.length === 0) {\n  const simpleKeywords = product.keywords || body.keywords || [];\n  if (Array.isArray(simpleKeywords) && simpleKeywords.length > 0) {\n    keywordSource = 'manual';\n    keywords = simpleKeywords.map(kw => {\n      if (typeof kw === 'string') {\n        return { phrase: kw, searchVolume: 0, relevancy: 0.5, priority: 0 };\n      }\n      return kw;\n    }).slice(0, 100);\n    keywordCount = keywords.length;\n    console.log('Loaded ' + keywords.length + ' keywords from keywords array');\n  }\n}\n\nif (keywords.length > 0) {\n  console.log('Top 5: ' + keywords.slice(0, 5).map(k => k.phrase).join(', '));\n} else {\n  console.log('No keyword data provided');\n}\n\nreturn [{ json: { \n  title, brand, description, price, sku, category, marketplaces: finalMarketplaces, specs,\n  keywords,\n  keywordSource,\n  keywordCount,\n  hasKeywordFile: keywords.length > 0\n} }];"
        }
      },
      {
        "id": "groq-bullets",
        "name": "Groq Generate Bullets",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          450,
          0
        ],
        "parameters": {
          "jsCode": "// Multi-Marketplace Bullet Generation v3.4 - SS Knowledge + Language Enforcement\n// EN enforcement, meta-comment filter, model fallback (70b\u21928b)\n// Updated: 2026-02-03\n\nconst input = $input.first().json;\nconst { title, brand, description, category, marketplaces, keywords, keywordSource, hasKeywordFile } = input;\nconst ssKnowledge = input.ss_knowledge || {};\n\nconst GROQ_API_KEY = 'gsk_REDACTED';\nconst DELAYS = { between_calls: 800, retry_base: 1500 };\n\nconst FORBIDDEN_WORDS = {\n  amazon_all: 'buy now, shop now, order now, add to cart, click here, best deal, cheapest, discount, sale, free shipping, #1, best, top rated, cure, heal, treat, prevent, prevents, preventing, antibacterial, antiviral, antimicrobial, therapeutic, amazon\\'s choice, prime eligible, 5-star, limited stock, hurry, replica, fake',\n  amazon_de: 'jetzt kaufen, bester preis, billigste, rabatt, kostenloser versand, beste, bio, oko, organic, heilt, verhindert, antibakteriell, begrenzter vorrat',\n  amazon_pl: 'kup teraz, najlepsza cena, rabat, promocja, darmowa wysylka, najlepszy, leczy, zapobiega, antybakteryjny, ograniczona ilosc',\n  ebay: 'buy now, best deal, free shipping, paypal only, no returns',\n  allegro: 'kup teraz, najlepsza cena, rabat, promocja, darmowa wysylka, najlepszy, ograniczona ilosc'\n};\n\nconst getForbiddenWordsForMp = (mp) => {\n  let words = FORBIDDEN_WORDS.amazon_all;\n  if (mp === 'amazon_de') words += ', ' + FORBIDDEN_WORDS.amazon_de;\n  if (mp === 'amazon_pl') words += ', ' + FORBIDDEN_WORDS.amazon_pl;\n  if (mp === 'ebay') words = FORBIDDEN_WORDS.ebay;\n  if (mp === 'allegro') words = FORBIDDEN_WORDS.allegro;\n  return words;\n};\n\nconst buildKeywordContext = (mp) => {\n  if (!hasKeywordFile || !keywords || keywords.length === 0) return '';\n  const topKw = keywords.slice(0, 20).map(k => k.phrase);\n  const highPriorityKw = keywords.slice(0, 5).map(k => k.phrase);\n  return '\\n\\nKEYWORD RESEARCH (' + keywordSource + '):\\nTOP PRIORITY (must appear in bullets): ' + highPriorityKw.join(', ') + '\\nADDITIONAL (weave naturally): ' + topKw.slice(5).join(', ');\n};\n\n// SS-Enhanced: System prompt with SellerSystems knowledge\nconst getSystemPrompt = (mp) => {\n  const baseMp = mp.startsWith('amazon') ? 'amazon' : mp;\n  if (baseMp === 'amazon') {\n    return 'You are an expert Amazon listing copywriter trained in the SellerSystems Inner Circle methodology by Brandon Young. You have deep knowledge of A9 algorithm optimization, Ranking Juice concepts, and conversion-focused copywriting.\\n\\n' + (ssKnowledge.bullets || '') + '\\n\\n' + (ssKnowledge.marketplace || '');\n  }\n  if (baseMp === 'allegro') {\n    return 'Jestes ekspertem Allegro z wiedza SellerSystems. Pisz TYLKO po polsku.\\n\\n' + (ssKnowledge.marketplace || '');\n  }\n  return 'You are a marketplace listing expert.\\n\\n' + (ssKnowledge.marketplace || '');\n};\n\nconst getPromptForMarketplace = (marketplace) => {\n  const baseInfo = 'Product: ' + title + '\\nBrand: ' + brand + '\\nCategory: ' + category + '\\nDescription: ' + description;\n  const kwContext = buildKeywordContext(marketplace);\n  const forbiddenWords = getForbiddenWordsForMp(marketplace);\n  const forbiddenWarning = '\\n\\nFORBIDDEN WORDS (NEVER use): ' + forbiddenWords;\n  \n  const strategies = {\n    amazon: { strategy: 'inner_circle_5_point', prompt: baseInfo + kwContext + forbiddenWarning + '\\n\\nIMPORTANT: Write ENTIRELY in English. If the product name is in another language, translate it to English first.\\n\\nGenerate 5 bullets using the MANDATORY 5-BULLET STRUCTURE from your training:\\n1. Main USP/differentiator\\n2. Primary feature -> benefit conversion\\n3. Quality/materials -> trust building\\n4. Versatility/use cases -> expand value\\n5. Risk reversal/guarantee\\n\\nEach bullet: CAPS HEADER - benefit text. 200-250 chars. Target different customer avatars. Front-load for mobile (first 150 chars most visible).\\nReturn ONLY 5 bullets, one per line.' },\n    ebay: { strategy: 'ebay_specs_benefits', prompt: baseInfo + kwContext + forbiddenWarning + '\\n\\nIMPORTANT: Write ENTIRELY in English. Translate any non-English product names.\\n\\nGenerate 5 bullets for eBay. Start each with bullet point. Under 100 chars, factual tone. Return ONLY 5 bullets.' },\n    etsy: { strategy: 'etsy_storytelling', prompt: baseInfo + kwContext + forbiddenWarning + '\\n\\nIMPORTANT: Write ENTIRELY in English.\\n\\nGenerate 5 warm storytelling bullets with emojis. Return ONLY 5 bullets.' },\n    allegro: { strategy: 'allegro_polish', prompt: baseInfo + kwContext + forbiddenWarning + '\\n\\nWygeneruj 5 punktow po POLSKU. WAZNE: NIE dodawaj numerow ani znakow na poczatku - tylko czysty tekst punktu! Przyklad dobry: \"Oryginalny produkt marki X\" Przyklad zly: \"1. Oryginalny\" lub \"- Oryginalny\"\\n\\n60-100 znakow kazdy. Zwroc TYLKO 5 punktow.' }\n  };\n  \n  if (marketplace.startsWith('amazon')) return strategies.amazon;\n  return strategies[marketplace] || { strategy: 'generic', prompt: 'Generate 5 bullets for ' + title + '.' };\n};\n\nconst FALLBACKS = {\n  amazon: (b, t, kw) => [\n    'SOLVE YOUR PROBLEM - ' + b + ' ' + t + ' delivers professional results',\n    'PREMIUM QUALITY - High-quality materials for lasting performance',\n    'STANDS OUT - Superior design sets us apart from alternatives',\n    'PERFECT FOR - Adapts to your daily needs at home or work',\n    b.toUpperCase() + ' GUARANTEE - Quality backed by our commitment'\n  ],\n  ebay: (b, t) => ['Brand New ' + b + ' ' + t + ' - 100% Authentic', 'Premium quality - Built to last', 'Fast shipping within 24 hours', '30-day returns accepted', 'Top-rated seller service'],\n  etsy: (b, t) => ['Welcome! This beautiful ' + t + ' is crafted with love', 'Premium materials for exceptional quality', 'Perfect gift for someone special', 'Practical and stylish for everyday', 'We are here to help anytime'],\n  allegro: (b, t) => [b + ' ' + t + ' - 100% oryginalny', 'Wysoka jakosc - materialy premium', 'Ekspresowa wysylka z Polski', '14 dni na zwrot - gwarancja satysfakcji', 'Profesjonalna obsluga klienta'],\n  generic: (b, t) => [b + ' ' + t + ' - Premium', 'High-quality materials', 'Fast shipping', 'Satisfaction guaranteed', 'Excellent support']\n};\n\nconst getFallback = (mp) => {\n  if (mp.startsWith('amazon')) return FALLBACKS.amazon(brand, title, keywords);\n  return (FALLBACKS[mp] || FALLBACKS.generic)(brand, title, keywords);\n};\n\nconst formatAllegroBullets = (bullets) => {\n  return bullets.map((bullet, index) => {\n    let clean = bullet\n      .replace(/^[\\d\\s\\.\\-\\)\\:]+/g, '')\n      .replace(/^[\\u2713\\u2714\\u2022\\u25CF\\u25CB\\u25AA\\u25AB]+\\s*/g, '')\n      .trim();\n    return (index + 1) + '. \\u2713 ' + clean;\n  });\n};\n\nconst MODELS = ['llama-3.3-70b-versatile', 'llama-3.1-8b-instant'];\n\nconst generateBullets = async (mp, retries = 2) => {\n  const { strategy, prompt } = getPromptForMarketplace(mp);\n  const systemPrompt = getSystemPrompt(mp);\n  \n  // Try each model - fallback to 8b-instant if 70b hits rate limit\n  for (const model of MODELS) {\n    for (let attempt = 0; attempt <= retries; attempt++) {\n      try {\n        const response = await this.helpers.httpRequest({\n          method: 'POST',\n          url: 'https://api.groq.com/openai/v1/chat/completions',\n          headers: { 'Authorization': 'Bearer ' + GROQ_API_KEY, 'Content-Type': 'application/json' },\n          body: {\n            model: model,\n            messages: [\n              { role: 'system', content: systemPrompt },\n              { role: 'user', content: prompt }\n            ],\n            temperature: 0.7,\n            max_tokens: 1200\n          },\n          json: true\n        });\n        \n        const content = response.choices && response.choices[0] && response.choices[0].message && response.choices[0].message.content || '';\n        let bullets = content.split('\\n').filter(line => line.trim().length > 15 && line.trim().length < 300);\n        // Strip meta-comments/preamble (LLM instruction leakage)\n        bullets = bullets.filter(line => {\n          const lower = line.toLowerCase().trim();\n          if (lower.startsWith('here are') || lower.startsWith('below are') || lower.startsWith('sure,') || lower.startsWith('sure!')) return false;\n          if (lower.startsWith('oto ') || lower.startsWith('ponizej') || lower.startsWith('poni\u017cej')) return false;\n          if (lower.includes('bullets for') || lower.includes('punkty opisuj') || lower.includes('punkty dla')) return false;\n          if (lower.endsWith(':') && lower.length < 80 && !lower.includes(' - ') && !lower.includes(' | ')) return false;\n          return true;\n        });\n        \n        if (bullets.length >= 3) {\n          if (mp === 'allegro') {\n            bullets = formatAllegroBullets(bullets.slice(0, 5));\n          } else {\n            bullets = bullets.slice(0, 5);\n          }\n          console.log(mp + ': AI generated ' + bullets.length + ' bullets (model: ' + model + ')');\n          return { bullets: bullets, strategy: strategy, aiGenerated: true, ssEnhanced: true, model: model, keywordsUsed: hasKeywordFile };\n        }\n      } catch (e) {\n        console.log(mp + ' ' + model + ' attempt ' + (attempt + 1) + ' failed: ' + e.message);\n        // On rate limit (429), skip remaining retries for this model and try next model\n        if (e.message && e.message.includes('429')) {\n          console.log(mp + ': Rate limit on ' + model + ', trying next model...');\n          break;\n        }\n        if (attempt < retries) await new Promise(r => setTimeout(r, DELAYS.retry_base));\n      }\n    }\n  }\n  \n  console.log(mp + ': Using fallback bullets');\n  let fallbackBullets = getFallback(mp);\n  if (mp === 'allegro') fallbackBullets = formatAllegroBullets(fallbackBullets);\n  return { bullets: fallbackBullets, strategy: strategy + '_fallback', aiGenerated: false, ssEnhanced: false, keywordsUsed: false };\n};\n\nconst bulletsByMarketplace = {};\nconst mpList = Array.isArray(marketplaces) ? marketplaces : ['amazon_us'];\n\nfor (const mp of mpList) {\n  bulletsByMarketplace[mp] = await generateBullets.call(this, mp);\n  if (mpList.indexOf(mp) < mpList.length - 1) await new Promise(r => setTimeout(r, DELAYS.between_calls));\n}\n\nreturn [{ json: { ...input, bulletsByMarketplace, bullets: bulletsByMarketplace[mpList.find(m => m.startsWith('amazon')) || mpList[0]].bullets || [] } }];\n"
        },
        "onError": "continueRegularOutput"
      },
      {
        "id": "groq-description",
        "name": "Groq Generate Description",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          625,
          0
        ],
        "parameters": {
          "jsCode": "// Multi-Marketplace Description Generation v3.4 - SS Knowledge + Language Enforcement\n// EN enforcement, PL strengthened, model fallback (70b\u21928b)\n// Updated: 2026-02-03\nconst input = $input.first().json;\nconst { title, brand, description, category, marketplaces, bulletsByMarketplace, keywords, hasKeywordFile } = input;\nconst ssKnowledge = input.ss_knowledge || {};\n\nconst GROQ_API_KEY = 'gsk_REDACTED';\nconst DELAYS = { between_calls: 800, retry_base: 1500 };\n\nconst FORBIDDEN_WORDS = {\n  amazon_all: 'buy now, shop now, order now, add to cart, click here, best deal, cheapest, discount, sale, #1, best, number one, top rated, cure, heal, treat, prevent, prevents, preventing, antibacterial, antimicrobial, antiviral, therapeutic, amazon\\'s choice, 5-star, limited stock, hurry, replica',\n  amazon_de: 'jetzt kaufen, jetzt bestellen, bester preis, bio, \u00f6ko, organic (without EU cert), heilt, verhindert, antibakteriell, nummer eins',\n  amazon_pl: 'kup teraz, zam\u00f3w teraz, najlepsza cena, najlepszy, leczy, zapobiega, antybakteryjny, numer jeden',\n  ebay: 'buy now, best deal, limited stock, amazon',\n  etsy: 'cheap, discount, amazon, mass-produced',\n  allegro: 'kup teraz, najtaniej, promocja, amazon'\n};\n\nconst getForbiddenWarning = (mp) => {\n  const base = FORBIDDEN_WORDS.amazon_all;\n  let specific = '';\n  if (mp.startsWith('amazon_de')) specific = FORBIDDEN_WORDS.amazon_de;\n  else if (mp.startsWith('amazon_pl')) specific = FORBIDDEN_WORDS.amazon_pl;\n  else if (mp === 'ebay') specific = FORBIDDEN_WORDS.ebay;\n  else if (mp === 'etsy') specific = FORBIDDEN_WORDS.etsy;\n  else if (mp === 'allegro') specific = FORBIDDEN_WORDS.allegro;\n  const allForbidden = specific ? base + ', ' + specific : base;\n  return '\\n\\nFORBIDDEN WORDS (NEVER use): ' + allForbidden + '\\nSAFE ALTERNATIVES: \"helps reduce\" instead of \"prevents\", \"supports\" instead of \"cures\", \"hygienic design\" instead of \"antibacterial\", \"premium\" instead of \"best\"';\n};\n\n// SS-Enhanced: Identify keywords already used in title and bullets\nconst getUsedKeywords = (mp) => {\n  const mpBullets = bulletsByMarketplace && bulletsByMarketplace[mp] ? bulletsByMarketplace[mp].bullets || [] : [];\n  const bulletText = mpBullets.join(' ').toLowerCase();\n  const titleText = (title || '').toLowerCase();\n  const usedInTitleAndBullets = (titleText + ' ' + bulletText);\n  \n  if (!hasKeywordFile || !keywords || keywords.length === 0) return { used: '', remaining: '' };\n  \n  const usedKw = [];\n  const remainingKw = [];\n  keywords.forEach(k => {\n    const phrase = (k.phrase || '').toLowerCase();\n    if (usedInTitleAndBullets.includes(phrase)) {\n      usedKw.push(phrase);\n    } else {\n      remainingKw.push(phrase);\n    }\n  });\n  \n  return { used: usedKw.join(', '), remaining: remainingKw.join(', ') };\n};\n\n// SS-Enhanced: System prompt with description knowledge\nconst getSystemPrompt = (mp) => {\n  const baseMp = mp.startsWith('amazon') ? 'amazon' : mp;\n  if (baseMp === 'amazon') {\n    return 'You are an expert Amazon listing copywriter trained in SellerSystems Inner Circle methodology. Your goal is to MAXIMIZE root word coverage - include keywords NOT already in the title and bullets.\\n\\n' + (ssKnowledge.description || '') + '\\n\\n' + (ssKnowledge.marketplace || '');\n  }\n  if (baseMp === 'allegro') {\n    return 'Jestes ekspertem Allegro z wiedza SellerSystems. Pisz TYLKO po polsku.\\n\\n' + (ssKnowledge.marketplace || '');\n  }\n  return 'You are a marketplace listing expert.\\n\\n' + (ssKnowledge.marketplace || '');\n};\n\nconst getDescPrompt = (mp) => {\n  const baseInfo = 'Product: ' + title + '\\nBrand: ' + brand + '\\nCategory: ' + category + '\\nBase description: ' + description;\n  const forbiddenWarning = getForbiddenWarning(mp);\n  const { used, remaining } = getUsedKeywords(mp);\n  \n  // SS-Enhanced: Tell Groq which keywords are already covered\n  const kwCoverage = used ? '\\n\\nKEYWORDS ALREADY IN TITLE/BULLETS (do NOT repeat heavily): ' + used : '';\n  const kwRemaining = remaining ? '\\nKEYWORDS TO INCLUDE IN DESCRIPTION (maximize coverage): ' + remaining : '';\n  \n  const strategies = {\n    amazon: { strategy: 'inner_circle_a9_ss', prompt: baseInfo + kwCoverage + kwRemaining + forbiddenWarning + '\\n\\nIMPORTANT: Write ENTIRELY in English. Translate any non-English product names to English first.\\n\\nWrite description targeting all 3 layers of A9:\\n1. LEXICAL - include remaining exact keywords listed above\\n2. SEMANTIC (BERT) - use synonyms and related terms\\n3. BEHAVIORAL (COSMO) - describe real use cases\\n\\n3 paragraphs: Lifestyle Hook, Core Value, Trust & Close. 150-300 words.\\nReturn ONLY the description text.' },\n    ebay: { strategy: 'ebay_specs', prompt: baseInfo + forbiddenWarning + '\\n\\nIMPORTANT: Write ENTIRELY in English. Translate any non-English product names.\\n\\nWrite eBay description:\\n1. Condition: Brand New\\n2. Overview (2-3 sentences)\\n3. Specifications (bullets)\\n4. What\\'s Included\\n5. Shipping & Returns\\n\\nDirect factual tone, 100-200 words.\\nReturn ONLY description.' },\n    etsy: { strategy: 'etsy_storytelling', prompt: baseInfo + forbiddenWarning + '\\n\\nIMPORTANT: Write ENTIRELY in English.\\n\\nWrite Etsy STORYTELLING description with artisan warmth:\\n1. Warm welcome\\n2. Story & craftsmanship\\n3. Details that matter\\n4. Perfect for occasions\\n5. Shop appreciation\\n\\nWarm friendly tone, tasteful emojis, 150-250 words.\\nReturn ONLY description.' },\n    allegro: { strategy: 'allegro_polish', prompt: baseInfo + forbiddenWarning + '\\n\\nNapisz opis CALKOWICIE po POLSKU. KAZDE zdanie musi byc po polsku. NIE uzywaj angielskiego.\\n\\nStruktura:\\n1. Naglowek: ' + brand + ' ' + title + '\\n2. Opis produktu\\n3. Cechy (checkmark przed kazdym)\\n4. Wysylka z Polski\\n5. Gwarancja satysfakcji\\n\\n100-200 slow.\\nZwroc TYLKO opis.' }\n  };\n  if (mp.startsWith('amazon')) return strategies.amazon;\n  return strategies[mp] || { strategy: 'generic', prompt: 'Write description for ' + title + '. 100-200 words.' + forbiddenWarning };\n};\n\nconst FALLBACKS = {\n  amazon: (b, t, d) => 'Discover the ' + b + ' ' + t + ', designed to enhance your daily routine. Whether you\\'re looking for reliability, quality, or value, this product delivers.\\n\\nCrafted with premium materials, the ' + b + ' ' + t + ' stands out from alternatives. Thoughtful design ensures lasting performance for beginners and experts alike.\\n\\nWith ' + b + '\\'s commitment to excellence, your purchase is backed by quality craftsmanship and satisfaction. Experience the difference.',\n  ebay: (b, t, d) => 'Condition: Brand New\\n\\n' + b + ' ' + t + ' - exactly what you need.\\n\\nSpecifications:\\n* Premium quality\\n* Authentic ' + b + ' product\\n* Full warranty\\n\\nWhat\\'s Included:\\n* 1x ' + t + '\\n* Original packaging\\n\\nShipping & Returns:\\n* Fast shipping within 24 hours\\n* 30-day money back guarantee',\n  etsy: (b, t, d) => 'Welcome to our shop!\\n\\nThis beautiful ' + b + ' ' + t + ' is crafted with love and attention. We believe in products that bring joy.\\n\\nMade with premium materials, combining quality with practical design.\\n\\nPerfect gift for birthdays, holidays, or just because!\\n\\nThank you for visiting! Your happiness is our priority!',\n  allegro: (b, t, d) => b + ' ' + t + ' - Oryginalny Produkt\\n\\nOpis:\\n' + d + '\\n\\nCechy produktu:\\n\u2713 Wysoka jakosc wykonania\\n\u2713 Oryginalne materialy\\n\u2713 Gwarancja producenta\\n\\nWysylka:\\n\u2713 Ekspresowa wysylka z Polski\\n\u2713 Bezpieczne pakowanie\\n\\n\u2713 14 dni na zwrot\\n\u2713 Gwarancja satysfakcji',\n  generic: (b, t, d) => b + ' ' + t + '\\n\\n' + d + '\\n\\nHigh-quality product. Fast shipping and satisfaction guaranteed.'\n};\n\nconst getFallback = (mp) => {\n  if (mp.startsWith('amazon')) return FALLBACKS.amazon(brand, title, description);\n  return (FALLBACKS[mp] || FALLBACKS.generic)(brand, title, description);\n};\n\nconst MODELS = ['llama-3.3-70b-versatile', 'llama-3.1-8b-instant'];\n\nconst generateDesc = async (mp, retries = 2) => {\n  const { strategy, prompt } = getDescPrompt(mp);\n  const systemPrompt = getSystemPrompt(mp);\n  \n  for (const model of MODELS) {\n  for (let attempt = 0; attempt <= retries; attempt++) {\n    try {\n      // SS-Enhanced: Use system + user messages\n      const response = await this.helpers.httpRequest({\n        method: 'POST',\n        url: 'https://api.groq.com/openai/v1/chat/completions',\n        headers: { 'Authorization': 'Bearer ' + GROQ_API_KEY, 'Content-Type': 'application/json' },\n        body: {\n          model: model,\n          messages: [\n            { role: 'system', content: systemPrompt },\n            { role: 'user', content: prompt }\n          ],\n          temperature: 0.7,\n          max_tokens: 1200\n        },\n        json: true\n      });\n      \n      const content = response.choices && response.choices[0] && response.choices[0].message && response.choices[0].message.content || '';\n      \n      if (content.length > 50) {\n        console.log(mp + ': SS-enhanced description (' + content.length + ' chars)');\n        return { description: content.trim(), strategy, aiGenerated: true, ssEnhanced: true };\n      }\n    } catch (e) {\n      console.log(mp + ' ' + model + ' desc attempt ' + (attempt + 1) + ' failed: ' + e.message);\n      if (e.message && e.message.includes('429')) {\n        console.log(mp + ': Rate limit on ' + model + ', trying next model...');\n        break;\n      }\n      if (attempt < retries) await new Promise(r => setTimeout(r, DELAYS.retry_base));\n    }\n  }\n  }\n  \n  console.log(mp + ': Using fallback description');\n  return { description: getFallback(mp), strategy: strategy + '_fallback', aiGenerated: false, ssEnhanced: false };\n};\n\nconst descriptionsByMarketplace = {};\nconst mpList = Array.isArray(marketplaces) ? marketplaces : ['amazon_us'];\n\nfor (const mp of mpList) {\n  descriptionsByMarketplace[mp] = await generateDesc.call(this, mp);\n  if (mpList.indexOf(mp) < mpList.length - 1) await new Promise(r => setTimeout(r, DELAYS.between_calls));\n}\n\nreturn [{ json: { ...input, descriptionsByMarketplace, description: descriptionsByMarketplace[mpList.find(m => m.startsWith('amazon')) || mpList[0]]?.description || description } }];\n"
        },
        "onError": "continueRegularOutput"
      },
      {
        "id": "generate-listings",
        "name": "Generate Listings",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          800,
          0
        ],
        "parameters": {
          "jsCode": "// Generate Listings v2.3 - TITLE LENGTH + ETSY 13 TAGS + EBAY SPECIFICS\n// Updated: 2026-02-03\n// CRITICAL: TITLE_LIMITS must match Groq Translate EU node - if you change limits here, change there too!\n\nconst input = $input.first().json;\nconst title = input.title || 'Product';\nconst brand = input.brand || 'Brand';\nconst category = input.category || 'General';\nconst price = input.price || '0';\nconst sku = input.sku || '';\nconst specs = input.specs || {};\nconst keywords = input.keywords || [];\nconst marketplaces = input.marketplaces || ['amazon', 'ebay', 'etsy', 'allegro'];\nconst bulletsByMarketplace = input.bulletsByMarketplace || {};\nconst descriptionsByMarketplace = input.descriptionsByMarketplace || {};\n\n// Helper: Get base marketplace name (amazon_us -> amazon)\nfunction getBaseMp(mp) {\n  if (mp.startsWith('amazon')) return 'amazon';\n  return mp;\n}\n\n// TITLE LENGTH REQUIREMENTS (ENFORCED!)\nconst TITLE_LIMITS = {\n  amazon: { min: 80, max: 200 },\n  ebay: { min: 60, max: 80 },\n  etsy: { min: 80, max: 140 },\n  allegro: { min: 30, max: 50 }\n};\n\n// Extend title to meet minimum length with SEO keywords\nfunction extendTitle(baseTitle, marketplace, brand, category, kws) {\n  const baseMp = getBaseMp(marketplace);\n  const limits = TITLE_LIMITS[baseMp];\n  if (!limits) return baseTitle;\n  let extended = baseTitle;\n  \n  const paddingWords = {\n    amazon: ['Premium Quality', 'Professional Grade', 'Durable Construction', 'High Performance', 'Heavy Duty', 'Multi-Purpose', 'Kitchen Essentials', 'Home & Kitchen'],\n    ebay: ['NEW', 'Fast Shipping', 'Top Quality', 'Authentic', 'Genuine Brand', '100% Original', 'Factory Sealed'],\n    etsy: ['Handmade', 'Unique Gift', 'Custom Made', 'Gift for Her', 'Gift for Him', 'Birthday Gift', 'Christmas Gift', 'Anniversary Gift', 'Personalized'],\n    allegro: ['Premium', 'Najwyzsza Jakosc', 'Oryginalny Produkt']\n  };\n  \n  const words = paddingWords[baseMp] || paddingWords.amazon;\n  let idx = 0;\n  \n  // Add keywords from research first\n  if (kws && kws.length > 0) {\n    kws.slice(0, 3).forEach(function(kw) {\n      const keyword = kw.keyword || kw.phrase || kw;\n      if (keyword && extended.length < limits.min && !extended.toLowerCase().includes(keyword.toLowerCase())) {\n        extended = extended + ' ' + keyword;\n      }\n    });\n  }\n  \n  // Then add padding words\n  while (extended.length < limits.min && idx < words.length) {\n    if (!extended.toLowerCase().includes(words[idx].toLowerCase())) {\n      extended = extended + ' ' + words[idx];\n    }\n    idx++;\n  }\n  \n  // Add category if still short\n  if (extended.length < limits.min && category && !extended.toLowerCase().includes(category.toLowerCase())) {\n    extended = extended + ' for ' + category;\n  }\n  \n  // Truncate if too long\n  if (extended.length > limits.max) {\n    extended = extended.substring(0, limits.max - 3).trim() + '...';\n  }\n  \n  return extended.trim();\n}\n\n// Clean Amazon bullets - remove * and bullet prefixes\nfunction cleanBullets(bullets) {\n  if (!Array.isArray(bullets)) return [];\n  return bullets.map(function(b) {\n    // Remove: *, bullet char, -, numbers with dots\n    return b.replace(/^[*\\u2022\\-]+\\s*/, '').replace(/^\\d+\\.\\s*/, '').trim();\n  });\n}\n\n// Generate exactly 13 Etsy tags (CRITICAL for Etsy SEO!)\nfunction generateEtsyTags(productTitle, brandName, cat, kws) {\n  const titleWords = productTitle.toLowerCase().split(' ').filter(function(w) { return w.length > 2; });\n  \n  const baseTags = [\n    titleWords.slice(0, 2).join(' ').substring(0, 20) || 'unique item',\n    'handmade gift',\n    'unique gift',\n    'gift for her',\n    'gift for him',\n    'birthday gift',\n    'christmas gift',\n    'anniversary gift',\n    'personalized gift',\n    'custom made',\n    (brandName || 'artisan').toLowerCase().substring(0, 20),\n    (cat || 'home goods').toLowerCase().substring(0, 20),\n    'special occasion'\n  ];\n  \n  // Add keywords if available\n  if (kws && kws.length > 0) {\n    kws.slice(0, 5).forEach(function(kw) {\n      const tag = (kw.keyword || kw.phrase || kw || '').toLowerCase().substring(0, 20);\n      if (tag && tag.length > 2) {\n        baseTags.push(tag);\n      }\n    });\n  }\n  \n  // Deduplicate and ensure 13 tags\n  const seen = {};\n  const uniqueTags = [];\n  baseTags.forEach(function(t) {\n    const clean = t.trim().substring(0, 20);\n    if (clean && !seen[clean] && uniqueTags.length < 13) {\n      seen[clean] = true;\n      uniqueTags.push(clean);\n    }\n  });\n  \n  // Pad with generic tags if needed\n  const padTags = ['home decor', 'minimalist style', 'boho chic', 'vintage inspired', 'modern design', 'eco friendly', 'sustainable', 'artisan made'];\n  let padIdx = 0;\n  while (uniqueTags.length < 13 && padIdx < padTags.length) {\n    if (!seen[padTags[padIdx]]) {\n      uniqueTags.push(padTags[padIdx]);\n      seen[padTags[padIdx]] = true;\n    }\n    padIdx++;\n  }\n  \n  return uniqueTags.slice(0, 13);\n}\n\n// Generate eBay item_specifics (CRITICAL for Cassini ranking!)\nfunction generateEbaySpecifics(brandName, cat, productSpecs) {\n  const specifics = {\n    'Brand': brandName || 'Unbranded',\n    'Type': cat || 'General',\n    'Condition': 'New',\n    'Country/Region of Manufacture': 'China',\n    'Material': productSpecs.material || 'See Description',\n    'Color': productSpecs.color || 'As Pictured',\n    'Size': productSpecs.size || 'Standard',\n    'Model': productSpecs.model || 'See Description',\n    'MPN': productSpecs.mpn || 'Does Not Apply',\n    'UPC': productSpecs.upc || 'Does Not Apply'\n  };\n  \n  // Add any additional specs from input\n  if (productSpecs && typeof productSpecs === 'object') {\n    Object.keys(productSpecs).forEach(function(key) {\n      var val = productSpecs[key];\n      if (val && typeof val === 'string' && val.length > 0) {\n        var capitalKey = key.charAt(0).toUpperCase() + key.slice(1).replace(/_/g, ' ');\n        if (!specifics[capitalKey]) {\n          specifics[capitalKey] = val;\n        }\n      }\n    });\n  }\n  \n  return specifics;\n}\n\n// Build listings for each marketplace\nconst listings = {};\n\nmarketplaces.forEach(function(mp) {\n  const mpLower = mp.toLowerCase();\n  const baseMp = getBaseMp(mpLower);\n  const baseTitle = (brand + ' ' + title).trim();\n  \n  // Get marketplace-specific content\n  const mpBulletData = bulletsByMarketplace[mpLower] || {};\n  const mpDescData = descriptionsByMarketplace[mpLower] || {};\n  const mpBullets = mpBulletData.bullets || [];\n  const mpDesc = mpDescData.description || input.description || '';\n  \n  // FIX: Clean bullets for ALL Amazon variants (amazon_us, amazon_de, etc.)\n  const cleanedBullets = baseMp === 'amazon' ? cleanBullets(mpBullets) : mpBullets;\n  \n  // Create listing object\n  listings[mpLower] = {\n    title: extendTitle(baseTitle, mpLower, brand, category, keywords),\n    title_length: 0,\n    bullets: cleanedBullets,\n    bullets_strategy: mpBulletData.strategy || 'default',\n    keywords_used: keywords.length > 0,\n    description: mpDesc,\n    description_strategy: mpDescData.strategy || 'default',\n    backend_keywords: keywords.length > 0 \n      ? keywords.map(function(k) { return k.keyword || k.phrase || k; }).join(' ').substring(0, 250)\n      : (title + ' ' + brand + ' ' + category).toLowerCase().substring(0, 250),\n    backend_keywords_count: Math.max(keywords.length, 1),\n    price: price,\n    language: mpLower === 'allegro' || mpLower === 'amazon_pl' ? 'PL' : 'EN'\n  };\n  \n  // Set actual title length\n  listings[mpLower].title_length = listings[mpLower].title.length;\n  \n  // ETSY: Add exactly 13 tags (REQUIRED!)\n  if (baseMp === 'etsy') {\n    listings[mpLower].tags = generateEtsyTags(title, brand, category, keywords);\n    listings[mpLower].tags_count = listings[mpLower].tags.length;\n  }\n  \n  // EBAY: Add item_specifics (CRITICAL for ranking!)\n  if (baseMp === 'ebay') {\n    listings[mpLower].item_specifics = generateEbaySpecifics(brand, category, specs);\n  }\n});\n\n// Build keyword statistics\nconst keywordStats = {\n  source: input.keywordSource || null,\n  total_uploaded: keywords.length,\n  used_in_backend: Math.max(keywords.length, 1),\n  keywords_in_bullets: keywords.length > 0\n};\n\nreturn [{\n  json: {\n    ...input,\n    listings: listings,\n    keywordStats: keywordStats,\n    generatedAt: new Date().toISOString()\n  }\n}];"
        }
      },
      {
        "id": "groq-translate",
        "name": "Groq Translate EU",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          975,
          0
        ],
        "parameters": {
          "jsCode": "// Groq Translate EU v3.14 - Bullet quality verification + retry\n// Fixes: product_name mode, Jogi\u2192Yoga, BULLET N: strip, PL name in descriptions\n// Updated: 2026-02-03\n\nconst data = $input.first().json;\nconst listings = { ...data.listings };\nconst debugLog = [];\n\n// 3 Groq API keys for rotation on rate limit\nconst GROQ_API_KEYS = [\n  'gsk_REDACTED',  // Primary\n  'gsk_REDACTED',  // Backup #1\n  'gsk_REDACTED'   // Backup #2\n];\nlet currentKeyIndex = 0;\n\nconst httpRequest = this.helpers.httpRequest.bind(this.helpers);\nconst sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));\n\nconst DELAYS = { \n  between_translations: 2000,\n  retry_base: 3000,\n  between_marketplaces: 1500\n};\n\nconst TITLE_LIMITS = {\n  amazon: { min: 80, max: 200 },\n  ebay: { min: 60, max: 80 },\n  etsy: { min: 80, max: 140 },\n  allegro: { min: 30, max: 50 }\n};\n\nconst TITLE_PADDING = {\n  DE: ['Premium-Qualit\u00e4t', 'Professionell', 'Hochwertig', 'Langlebig', 'Erstklassig'],\n  FR: ['Haute Qualit\u00e9', 'Premium', 'Professionnel', 'Durable', 'Excellence'],\n  IT: ['Alta Qualit\u00e0', 'Premium', 'Professionale', 'Durevole', 'Eccellente'],\n  ES: ['Alta Calidad', 'Premium', 'Profesional', 'Duradero', 'Excelente'],\n  NL: ['Hoogwaardige', 'Premium Kwaliteit', 'Professioneel', 'Duurzaam'],\n  SV: ['H\u00f6gkvalitativ', 'Premium', 'Professionell', 'H\u00e5llbar'],\n  PL: ['Wysoka Jako\u015b\u0107', 'Premium', 'Profesjonalny', 'Trwa\u0142y', 'Doskona\u0142y'],\n  EN: ['Premium Quality', 'Professional Grade', 'Heavy Duty', 'Durable', 'Multi-Purpose']\n};\n\ndebugLog.push('=== Groq Translate EU v3.13 (title lang verify + retry) ===');\ndebugLog.push(`Available API keys: ${GROQ_API_KEYS.length}`);\n\nfunction switchToNextKey() {\n  if (currentKeyIndex < GROQ_API_KEYS.length - 1) {\n    currentKeyIndex++;\n    debugLog.push(`Switched to key #${currentKeyIndex + 1}`);\n    return true;\n  }\n  debugLog.push('All keys exhausted!');\n  return false;\n}\n\nasync function translateWithGroq(text, targetLang, mode) {\n  const langNames = { DE: 'German', PL: 'Polish', FR: 'French', IT: 'Italian', ES: 'Spanish', NL: 'Dutch', SV: 'Swedish', EN: 'English' };\n  const langName = langNames[targetLang] || 'German';\n  \n  // Mode-aware system prompt: specialized for bullets and product names\n  let systemMsg;\n  if (mode === 'product_name') {\n    systemMsg = `You are a professional e-commerce translator. Translate this product name from its original language to ${langName}. IMPORTANT RULES:\n- This is a PRODUCT NAME for an online listing, not a person's name\n- Translate ALL words including sport/activity terms (e.g., \"Jogi\"/\"Yoga\" \u2192 use the ${langName} word for Yoga)\n- \"Mata do Jogi\" = \"Yoga Mat\" in English, \"Yogamatte\" in German\n- \"Antypo\u015blizgowa\" = \"Anti-Slip\"/\"Non-Slip\" in English, \"Antirutsch\"/\"Rutschfest\" in German\n- Return ONLY the translated product name, nothing else`;\n  } else if (mode === 'bullets') {\n    systemMsg = `You are a translator. Translate each line below to ${langName}. RULES:\n- Translate EACH line word-by-word to ${langName}\n- Keep the SAME number of lines (one translated line per input line)\n- Keep CAPS HEADER format (translate the header words too)\n- Keep bullet markers (-, \u2022, numbers)\n- Do NOT add category labels, section headers, or framework structure\n- Do NOT reorganize or regenerate content\n- Return ONLY the translated lines`;\n  } else {\n    systemMsg = `You are a professional translator. Translate the user's text to ${langName}. Return ONLY the translated text. No explanations, no commentary, no instructions.`;\n  }\n  const userMsg = text;\n  \n  for (let attempt = 0; attempt < 6; attempt++) {\n    try {\n      const response = await httpRequest({\n        method: 'POST',\n        url: 'https://api.groq.com/openai/v1/chat/completions',\n        headers: {\n          'Authorization': `Bearer ${GROQ_API_KEYS[currentKeyIndex]}`,\n          'Content-Type': 'application/json'\n        },\n        body: {\n          model: 'llama-3.3-70b-versatile',\n          messages: [\n            { role: 'system', content: systemMsg },\n            { role: 'user', content: userMsg }\n          ],\n          temperature: 0.3,\n          max_tokens: 1500\n        },\n        json: true\n      });\n      \n      if (response?.choices?.[0]) {\n        let result = response.choices[0].message.content.trim();\n        // Safety net: strip instruction echo if LLM repeated the prompt\n        if (result.includes('\\n\\n')) {\n          const parts = result.split('\\n\\n');\n          const first = parts[0].toLowerCase();\n          const echoWords = ['must', 'critical', 'translate', 'muss', 'kritisch', 'traduire', 'tradurre', 'traducir', 'przet\u0142umacz', 'tylko'];\n          if (echoWords.some(w => first.includes(w))) {\n            result = parts.slice(1).join('\\n\\n').trim();\n          }\n        }\n        // Strip \"Translation:\" prefixes in any language\n        result = result.replace(/^(Translation|\u00dcbersetzung|Traduction|Traducci\u00f3n|Traduzione|T\u0142umaczenie)\\s*:\\s*/i, '');\n        return result;\n      }\n      throw new Error('Invalid response');\n    } catch (error) {\n      const is429 = error.message.includes('429');\n      \n      if (is429) {\n        debugLog.push(`Rate limited (key #${currentKeyIndex + 1})`);\n        if (switchToNextKey()) {\n          await sleep(1000);\n          continue;\n        }\n      }\n      \n      if (attempt < 5) {\n        await sleep(DELAYS.retry_base * (attempt + 1));\n      } else {\n        throw error;\n      }\n    }\n  }\n}\n\nfunction fixPolishGrammar(text) {\n  if (!text) return text;\n  return text\n    .replace(/\\bz stali/gi, 'ze stali')\n    .replace(/\\bz szk\u0142a/gi, 'ze szk\u0142a')\n    .replace(/\\bz srebra/gi, 'ze srebra');\n}\n\n// Strip newlines and LLM explanation artifacts from titles\n// Groq sometimes returns \"X becomes Y\" or \"Since the text is already...\" instead of clean translation\nfunction cleanTitleArtifacts(title) {\n  if (!title) return title;\n  // Strip parenthetical LLM meta-comments: \"(No translation needed)\", \"(Already in English)\", etc.\n  let clean = title.replace(/\\s*\\((No translation|Already|Note|Translation|Original)[^)]*\\)/gi, '').trim();\n  // Strip newlines \u2014 titles must be single-line\n  if (clean.includes('\\n')) {\n    const lines = clean.split('\\n')\n      .map(l => l.trim())\n      .filter(l => l.length > 5)\n      .filter(l => !/^(becomes|since|here is|note:|translation:)/i.test(l));\n    clean = (lines[0] || clean.split('\\n')[0]).trim();\n  }\n  return clean;\n}\n\nfunction mergeBulletPairs(lines) {\n  // Merge header+content split: short header line followed by long content paragraph\n  // e.g. \"**HEADER** - Subtitle\" (58ch) + \"Content paragraph...\" (272ch) \u2192 merged\n  const merged = [];\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i].trim();\n    const nextLine = i + 1 < lines.length ? lines[i + 1].trim() : '';\n    const isShort = line.length < 80;\n    const nextIsLong = nextLine.length > 100;\n    const lengthRatio = nextLine.length > 3 * line.length;\n    const hasBoldMarkers = line.includes('**');\n    if (isShort && nextIsLong && (lengthRatio || hasBoldMarkers)) {\n      merged.push(line + ' ' + nextLine);\n      i++;\n    } else {\n      merged.push(line);\n    }\n  }\n  return merged;\n}\n\nfunction cleanBulletArtifacts(bullet) {\n  if (!bullet) return bullet;\n  // Remove \"BULLET N:\" or \"**BULLET N:**\" prefixes\n  let clean = bullet.replace(/^\\*?\\*?\\s*BULLET\\s*\\d+\\s*:?\\*?\\*?\\s*/i, '').trim();\n  // Remove leading \"N.\" or \"N)\" numbering if followed by content\n  clean = clean.replace(/^\\d+[.):]\\s*/, '').trim();\n  return clean || bullet;\n}\n\nfunction extendTitle(title, lang, minLen, maxLen) {\n  let ext = title.trim();\n  if (ext.length >= minLen) {\n    return ext.length > maxLen ? ext.slice(0, maxLen - 3).trim() + '...' : ext;\n  }\n  const padding = TITLE_PADDING[lang] || TITLE_PADDING.DE;\n  for (const word of padding) {\n    if (ext.length >= minLen) break;\n    if (!ext.toLowerCase().includes(word.toLowerCase())) ext += ' ' + word;\n  }\n  return ext.length > maxLen ? ext.slice(0, maxLen - 3).trim() + '...' : ext.trim();\n}\n\nasync function translateListing(listing, targetLang, marketplace, originalData) {\n  const baseMp = marketplace.startsWith('amazon') ? 'amazon' : marketplace;\n  const limits = TITLE_LIMITS[baseMp] || TITLE_LIMITS.amazon;\n  \n  let translatedTitle, translatedBullets, translatedDesc;\n  let usedFallback = false;\n  \n  try {\n    debugLog.push(`[${marketplace}] Translating to ${targetLang}`);\n    \n    // Translate RAW product name (not padded title) to avoid LLM treating PL as proper noun\n    // listing.title = \"Brand ProductNamePL keyword1 padding...\" (mixed languages, confuses LLM)\n    // originalData.title = \"ProductNamePL\" (clean, single language \u2014 translates properly)\n    const brandPrefix = (originalData.brand || '').trim();\n    const rawProductName = originalData.title || listing.title;\n    let productToTranslate = rawProductName;\n    // Strip brand if present in raw name too\n    if (brandPrefix && productToTranslate.startsWith(brandPrefix)) {\n      productToTranslate = productToTranslate.slice(brandPrefix.length).trim();\n    }\n    translatedTitle = await translateWithGroq(productToTranslate, targetLang, 'product_name');\n    translatedTitle = translatedTitle.replace(/^[\"']|[\"']$/g, '').trim();\n    translatedTitle = cleanTitleArtifacts(translatedTitle);\n    // Verify title is in target language \u2014 retry if source language (PL/EN) detected\n    const titleChk = ' ' + translatedTitle.toLowerCase() + ' ';\n    let titleRetry = false;\n    // Polish chars in non-PL title = untranslated\n    if (targetLang !== 'PL' && /[\u0105\u0107\u0119\u0142\u015b\u017a\u017c]/i.test(translatedTitle)) {\n      titleRetry = true;\n      debugLog.push(`[${marketplace}] Title has Polish chars, retrying`);\n    }\n    if (!titleRetry) {\n      // PL-specific function words (won't appear in DE/FR/IT/ES product names)\n      const plOnly = [' ze ', ' dla ', ' si\u0119 '];\n      // EN function words (shouldn't be in non-EN product names)\n      const enOnly = [' with ', ' the '];\n      if (targetLang !== 'PL' && plOnly.some(w => titleChk.includes(w))) {\n        titleRetry = true;\n        debugLog.push(`[${marketplace}] Title has PL words, retrying`);\n      } else if (enOnly.some(w => titleChk.includes(w))) {\n        titleRetry = true;\n        debugLog.push(`[${marketplace}] Title has EN words, retrying`);\n      }\n    }\n    if (titleRetry) {\n      await sleep(DELAYS.between_translations);\n      const langFull = {DE:'German',PL:'Polish',FR:'French',IT:'Italian',ES:'Spanish',NL:'Dutch',SV:'Swedish'}[targetLang] || targetLang;\n      const retryT = await translateWithGroq(\n        'TRANSLATE THIS PRODUCT NAME TO ' + langFull + ': ' + productToTranslate,\n        targetLang, 'product_name'\n      );\n      if (retryT && retryT.length > 5) {\n        translatedTitle = retryT.replace(/^[\"']|[\"']$/g, '').trim();\n        translatedTitle = cleanTitleArtifacts(translatedTitle);\n        debugLog.push(`[${marketplace}] Title retry applied`);\n      }\n    }\n    if (targetLang === 'PL') translatedTitle = fixPolishGrammar(translatedTitle);\n    // Rebuild: brand + translated product name, then pad to meet min length\n    translatedTitle = brandPrefix ? (brandPrefix + ' ' + translatedTitle).trim() : translatedTitle;\n    translatedTitle = extendTitle(translatedTitle, targetLang, limits.min, limits.max);\n    debugLog.push(`[${marketplace}] Title OK (from raw product name)`);\n    \n    // Pre-replace Polish product name in description with translated version\n    // Prevents \"Mata do Jogi Antypo\u015blizgowa\" appearing in German/French/etc descriptions\n    const escapeRx = (s) => s.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n    let cleanTranslatedName = translatedTitle;\n    if (brandPrefix) cleanTranslatedName = cleanTranslatedName.replace(brandPrefix, '').trim();\n    const padWords = TITLE_PADDING[targetLang] || [];\n    for (const pw of padWords) {\n      cleanTranslatedName = cleanTranslatedName.replace(new RegExp('\\\\s*' + escapeRx(pw) + '$', 'i'), '').trim();\n    }\n    if (productToTranslate && productToTranslate.length > 5 && cleanTranslatedName.length > 3) {\n      const fullPolishName = brandPrefix ? (brandPrefix + ' ' + productToTranslate) : productToTranslate;\n      listing.description = listing.description\n        .replace(new RegExp(escapeRx(fullPolishName), 'gi'), brandPrefix ? (brandPrefix + ' ' + cleanTranslatedName) : cleanTranslatedName)\n        .replace(new RegExp(escapeRx(productToTranslate), 'gi'), cleanTranslatedName);\n      debugLog.push(`[${marketplace}] Replaced PL product name in desc`);\n    }\n    \n    await sleep(DELAYS.between_translations);\n    \n    const bulletsText = listing.bullets.join('\\n');\n    try {\n      const bulletsResponse = await translateWithGroq(bulletsText, targetLang, 'bullets');\n      let parsed = bulletsResponse.split('\\n').filter(l => l.trim().length > 10);\n      \n      // Merge header+content split (IT/ES/NL pattern)\n      parsed = mergeBulletPairs(parsed);\n      \n      // Filter meta-comment bullets (framework headers LLM generates instead of translating)\n      parsed = parsed.filter(b => {\n        const stripped = b.replace(/\\*\\*/g, '').trim();\n        // Skip lines that are JUST uppercase category headers (no product content)\n        if (/^[A-Z\\u00C0-\\u024F\\s\\/\\-\\>\u2192:&]+$/.test(stripped) && stripped.length < 80) return false;\n        // Skip lines that are framework labels (MAIN USP, DIFFERENTIATOR, etc.)\n        if (/^(BULLET\\s*\\d|MAIN\\s+USP|DIFFERENTIATOR|KEY\\s+(SELLING|FEATURE)|QUALITY|TRUST|PRIMARY\\s+FEATURE|VERSATIL)/i.test(stripped)) return false;\n        // Skip lines too short to be real bullets\n        if (stripped.length < 30) return false;\n        return true;\n      }).slice(0, 5);\n      parsed = parsed.map(b => cleanBulletArtifacts(b));\n      if (targetLang === 'PL') parsed = parsed.map(b => fixPolishGrammar(b));\n      \n      // Bullet quality retry: if < 5 good bullets, retry with simpler prompt\n      if (parsed.length < 5) {\n        debugLog.push(`[${marketplace}] Only ${parsed.length} bullets, retrying translation...`);\n        await sleep(DELAYS.between_translations);\n        const langFull = {DE:'German',PL:'Polish',FR:'French',IT:'Italian',ES:'Spanish',NL:'Dutch',SV:'Swedish'}[targetLang] || targetLang;\n        const retryBulletsText = listing.bullets.map((b, i) => (i+1) + '. ' + b.replace(/\\*\\*/g, '').replace(/^[-\u2022]\\s*/, '').trim()).join('\\n');\n        try {\n          const retryResp = await translateWithGroq(\n            'Translate these 5 product bullet points to ' + langFull + '. CRITICAL RULES:\\n1. Return EXACTLY 5 lines\\n2. Each line = **BOLD HEADER** - full description paragraph (100+ chars)\\n3. Do NOT split header and description into separate lines\\n4. Each bullet must be self-contained on ONE line\\n\\n' + retryBulletsText,\n            targetLang, 'bullets'\n          );\n          let retryParsed = retryResp.split('\\n')\n            .map(l => l.trim())\n            .filter(l => l.length > 10);\n          retryParsed = mergeBulletPairs(retryParsed);\n          retryParsed = retryParsed\n            .filter(l => l.replace(/\\*\\*/g, '').trim().length > 30)\n            .map(b => cleanBulletArtifacts(b))\n            .slice(0, 5);\n          if (targetLang === 'PL') retryParsed = retryParsed.map(b => fixPolishGrammar(b));\n          if (retryParsed.length > parsed.length) {\n            parsed = retryParsed;\n            debugLog.push(`[${marketplace}] Bullet retry OK: ${retryParsed.length} bullets`);\n          }\n        } catch (retryErr) {\n          debugLog.push(`[${marketplace}] Bullet retry failed: ${retryErr.message}`);\n        }\n      }\n      \n      translatedBullets = parsed.length >= 3 ? parsed : listing.bullets;\n      debugLog.push(`[${marketplace}] Bullets: ${translatedBullets.length}`);\n    } catch (e) {\n      debugLog.push(`[${marketplace}] Bullets fallback`);\n      translatedBullets = listing.bullets;\n    }\n    \n    await sleep(DELAYS.between_translations);\n    \n    translatedDesc = await translateWithGroq(listing.description, targetLang);\n    // Verify translation actually changed language \u2014 LLM sometimes returns source text\n    const descHasTarget = (() => {\n      const d = ' ' + translatedDesc.toLowerCase() + ' ';\n      const markers = {\n        DE: [' und ', ' mit ', ' aus ', ' der ', ' die ', ' das '],\n        PL: [' do ', ' ze ', ' dla ', ' na ', ' jest ', ' si\u0119 '],\n        FR: [' et ', ' avec ', ' dans ', ' pour ', ' les '],\n        IT: [' e ', ' con ', ' della ', ' per ', ' una '],\n        ES: [' y ', ' con ', ' para ', ' una ', ' del ']\n      };\n      const check = markers[targetLang] || [];\n      return check.filter(w => d.includes(w)).length >= 2;\n    })();\n    if (!descHasTarget && translatedDesc.length > 100) {\n      debugLog.push(`[${marketplace}] Description may not be in ${targetLang}, retrying...`);\n      await sleep(DELAYS.between_translations);\n      const retry = await translateWithGroq(\n        'TRANSLATE TO ' + targetLang + ': ' + listing.description.slice(0, 1500),\n        targetLang\n      );\n      if (retry && retry.length > 50) translatedDesc = retry;\n    }\n    if (targetLang === 'PL') translatedDesc = fixPolishGrammar(translatedDesc);\n    debugLog.push(`[${marketplace}] Description OK`);\n    \n  } catch (error) {\n    debugLog.push(`[${marketplace}] FALLBACK: ${error.message}`);\n    usedFallback = true;\n    \n    const brand = originalData.brand || 'Brand';\n    const origTitle = originalData.title || 'Product';\n    let fallbackTitle = `${brand} ${origTitle}`;\n    const padding = TITLE_PADDING[targetLang] || TITLE_PADDING.DE;\n    for (const word of padding) {\n      if (fallbackTitle.length >= limits.min) break;\n      fallbackTitle += ' ' + word;\n    }\n    translatedTitle = extendTitle(fallbackTitle, targetLang, limits.min, limits.max);\n    translatedBullets = listing.bullets;\n    translatedDesc = listing.description;\n  }\n  \n  return {\n    ...listing,\n    title: translatedTitle,\n    title_length: translatedTitle.length,\n    bullets: translatedBullets,\n    description: translatedDesc,\n    language: targetLang,\n    translated: !usedFallback,\n    fallback_used: usedFallback\n  };\n}\n\nconst LANG_MAP = {\n  allegro: 'PL',\n  amazon_pl: 'PL',\n  amazon_de: 'DE',\n  amazon_fr: 'FR',\n  amazon_it: 'IT',\n  amazon_es: 'ES',\n  amazon_nl: 'NL',\n  amazon_se: 'SV'\n};\n\ntry {\n  for (const [mp, lang] of Object.entries(LANG_MAP)) {\n    if (listings[mp]) {\n      listings[mp] = await translateListing(listings[mp], lang, mp, data);\n      await sleep(DELAYS.between_marketplaces);\n    }\n  }\n  // Translate titles to English for EN markets if product name is non-English\n  const EN_MARKETS = ['amazon_us', 'amazon_uk', 'ebay', 'etsy'];\n  // Detect non-English text: diacritics OR common non-English word patterns\n  const looksNonEnglish = (text) => {\n    if (/[^\\x00-\\x7F]/.test(text)) return true;\n    const lower = ' ' + text.toLowerCase() + ' ';\n    const patterns = [' do ', ' ze ', ' z ', ' dla ', ' na ', ' nie ', ' od ', ' lub ', ' jak ', ' jest ', ' czosnku ', ' stali ', ' aus ', ' und ', ' fuer ', ' mit ', ' von ', ' der ', ' die ', ' das ', ' pour ', ' avec ', ' dans ', ' para ', ' con ', ' della '];\n    if (patterns.some(p => lower.includes(p))) return true;\n    // Polish word suffixes (instrumental/genitive case: filtrem, jonizatorem, powietrza)\n    if (/\\b\\w+(iem|rem|torem|\u00f3wk|o\u015bci|acja|aniu|eniu|owiec)\\b/i.test(text)) return true;\n    return false;\n  };\n  \n  // Translate raw product name to EN once, then replace in each EN market title\n  const origProductTitle = data.title || '';\n  let enProductNameCache = null;\n  if (origProductTitle && looksNonEnglish(origProductTitle)) {\n    try {\n      enProductNameCache = await translateWithGroq(origProductTitle, 'EN', 'product_name');\n      enProductNameCache = enProductNameCache.replace(/^[\"']|[\"']$/g, '').trim();\n      debugLog.push(`EN product name: \"${enProductNameCache}\"`);\n    } catch(e) {\n      debugLog.push(`EN product name translation failed: ${e.message}`);\n    }\n    await sleep(DELAYS.between_translations);\n  }\n  \n  const escRegex = (s) => s.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n  for (const mp of EN_MARKETS) {\n    if (listings[mp] && looksNonEnglish(listings[mp].title)) {\n      debugLog.push(`[${mp}] Title has non-English chars, translating to EN`);\n      try {\n        let enTitle = listings[mp].title;\n        // Replace Polish product name with cached EN translation (gives LLM a head start)\n        if (enProductNameCache && origProductTitle) {\n          enTitle = enTitle.replace(new RegExp(escRegex(origProductTitle), 'gi'), enProductNameCache);\n        }\n        // ALWAYS translate full title to catch remaining PL keywords used as title padding\n        enTitle = await translateWithGroq(enTitle, 'EN');\n        enTitle = enTitle.replace(/^[\"']|[\"']$/g, '').trim();\n        enTitle = cleanTitleArtifacts(enTitle);\n        // Verify EN title doesn't contain non-English text (e.g. Spanish from LLM glitch)\n        const enChk = ' ' + enTitle.toLowerCase() + ' ';\n        const nonEnMk = [' und ', ' mit ', ' f\u00fcr ', ' der ', ' die ', ' con ', ' para ', ' del ', ' avec ', ' pour ', ' dans ', ' ze ', ' dla ', ' och ', ' med '];\n        const brandClean = enTitle.replace(data.brand || '', '');\n        if (nonEnMk.some(w => enChk.includes(w)) || /[\u0105\u0107\u0119\u0142\u0144\u00f3\u015b\u017a\u017c\u00e4\u00f6\u00fc\u00df\u00e0\u00e2\u00e9\u00e8\u00ea\u00eb\u00ef\u00f4\u00f9\u00fb\u00fc\u00ff\u00e7\u00e1\u00e9\u00ed\u00f3\u00fa\u00f1\u00e5\u00f6]/i.test(brandClean)) {\n          debugLog.push(`[${mp}] EN title has non-English content, retrying...`);\n          await sleep(DELAYS.between_translations);\n          const retryEn = await translateWithGroq('TRANSLATE TO ENGLISH: ' + enTitle, 'EN');\n          if (retryEn && retryEn.length > 10) {\n            enTitle = retryEn.replace(/^[\"']|[\"']$/g, '').trim();\n            enTitle = cleanTitleArtifacts(enTitle);\n            debugLog.push(`[${mp}] EN title retry applied`);\n          }\n        }\n        const baseMp = mp.startsWith('amazon') ? 'amazon' : mp;\n        const limits = TITLE_LIMITS[baseMp] || TITLE_LIMITS.amazon;\n        enTitle = extendTitle(enTitle, 'EN', limits.min, limits.max);\n        listings[mp].title = enTitle;\n        listings[mp].title_length = enTitle.length;\n        listings[mp].title_translated_to_en = true;\n        debugLog.push(`[${mp}] EN title: ${enTitle.length} chars`);\n      } catch (e) {\n        debugLog.push(`[${mp}] EN title translation failed: ${e.message}`);\n      }\n      await sleep(DELAYS.between_translations);\n    }\n  }\n  \n  // Fix Polish product name in EN market descriptions (from fallback templates)\n  const origProductName = data.title || '';\n  if (origProductName && looksNonEnglish(origProductName)) {\n    const escRx = (s) => s.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n    for (const mp of EN_MARKETS) {\n      if (listings[mp] && listings[mp].description) {\n        const desc = listings[mp].description;\n        if (desc.includes(origProductName) || desc.includes((data.brand || '') + ' ' + origProductName)) {\n          // Extract clean EN product name from translated title\n          let enName = listings[mp].title || '';\n          const brand = (data.brand || '').trim();\n          if (brand) enName = enName.replace(brand, '').trim();\n          for (const pw of (TITLE_PADDING.EN || [])) {\n            enName = enName.replace(new RegExp('\\\\s*' + escRx(pw) + '$', 'i'), '').trim();\n          }\n          if (enName.length > 3) {\n            const fullPL = brand ? (brand + ' ' + origProductName) : origProductName;\n            listings[mp].description = desc\n              .replace(new RegExp(escRx(fullPL), 'gi'), brand ? (brand + ' ' + enName) : enName)\n              .replace(new RegExp(escRx(origProductName), 'gi'), enName);\n            debugLog.push(`[${mp}] Replaced PL product name in EN description`);\n          }\n        }\n      }\n    }\n  }\n  \n  // Universal bullet cleanup for ALL marketplaces (catches meta-comments from both generation and translation)\n  for (const mp of Object.keys(listings)) {\n    if (listings[mp] && listings[mp].bullets) {\n      listings[mp].bullets = listings[mp].bullets\n        .map(b => cleanBulletArtifacts(b))\n        .filter(b => {\n          const stripped = b.replace(/\\*\\*/g, '').trim();\n          // Remove framework headers that slipped through\n          if (/^(BULLET\\s*\\d|MAIN\\s+USP|DIFFERENTIATOR|KEY\\s+(SELLING|FEATURE)|QUALITY|TRUST)/i.test(stripped)) return false;\n          if (/^[A-Z\\s\\/\\-\\>\u2192:]+$/.test(stripped) && stripped.length < 60) return false;\n          return stripped.length > 15;\n        });\n      // Ensure at least 3 bullets (keep originals if filter removed too many)\n      if (listings[mp].bullets.length < 3) {\n        listings[mp].bullets = ($input.first().json.listings?.[mp]?.bullets || listings[mp].bullets);\n      }\n    }\n  }\n  \n  // Pre-replace Polish product name in non-EN bullets that still contain it\n  const origPN = data.title || '';\n  if (origPN) {\n    const escPN = (s) => s.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n    for (const [mp, listing] of Object.entries(listings)) {\n      if (listing.translated && listing.language !== 'EN') {\n        const translatedName = listing.title.replace(data.brand || '', '').trim()\n          .replace(/\\s*(Premium|Professionell|Hochwertig|Langlebig|Erstklassig|Haute|Wysoka|Doskona\u0142y).*$/i, '').trim();\n        if (translatedName.length > 3) {\n          listing.bullets = listing.bullets.map(b =>\n            b.replace(new RegExp(escPN(origPN), 'gi'), translatedName)\n          );\n          listing.description = listing.description.replace(new RegExp(escPN(origPN), 'gi'), translatedName);\n        }\n      }\n    }\n  }\n  \n  debugLog.push(`Complete (used key #${currentKeyIndex + 1})`);\n  return [{ json: { ...data, listings, translationsApplied: true, debug: debugLog } }];\n} catch (error) {\n  debugLog.push(`ERROR: ${error.message}`);\n  return [{ json: { ...data, listings, translationsApplied: false, translateError: error.message, debug: debugLog } }];\n}"
        },
        "onError": "continueRegularOutput"
      },
      {
        "id": "format-response",
        "name": "Format Response",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          1150,
          0
        ],
        "parameters": {
          "jsCode": "// Format Response - Final output with Forbidden Words Validation\nconst data = $input.first().json;\n\n// Safe access with defaults\nconst title = data.title || 'Product';\nconst description = data.description || '';\nconst brand = data.brand || '';\nconst listings = data.listings || {};\nconst marketplaces = data.marketplaces || Object.keys(listings);\nconst keywordStats = data.keywordStats || null;\nconst hasKeywordFile = data.hasKeywordFile || false;\n\n// Get keywords array (from Process Input)\nconst keywordsArray = data.keywords || [];\n\n// === FORBIDDEN WORDS VALIDATION ===\nconst RULES = [\n  // PROMOTIONAL CTA\n  { id: 'promo_buy_now_en', pattern: '\\\\b(buy now|shop now|order now|order today|add to cart|click here|act now|limited time)\\\\b', marketplaces: ['amazon_us', 'amazon_uk', 'ebay', 'etsy'], severity: 'block', category: 'promotional_cta', suggestion: 'Remove CTA phrases' },\n  { id: 'promo_buy_now_de', pattern: '\\\\b(jetzt kaufen|jetzt bestellen|in den warenkorb|nicht verpassen|begrenzte zeit)\\\\b', marketplaces: ['amazon_de'], severity: 'block', category: 'promotional_cta', suggestion: 'CTA-Phrasen entfernen' },\n  { id: 'promo_buy_now_pl', pattern: '\\\\b(kup teraz|zam\u00f3w teraz|dodaj do koszyka|nie przegap|tylko teraz)\\\\b', marketplaces: ['amazon_pl', 'allegro'], severity: 'block', category: 'promotional_cta', suggestion: 'Usu\u0144 CTA' },\n  \n  // PRICING\n  { id: 'pricing_en', pattern: '\\\\b(best deal|best price|cheapest|lowest price|save money|discount|sale|on sale|free shipping)\\\\b', marketplaces: ['amazon_us', 'amazon_uk', 'ebay'], severity: 'block', category: 'pricing_claims', suggestion: 'Remove pricing language' },\n  { id: 'pricing_de', pattern: '\\\\b(bester preis|billigste|g\u00fcnstigste|sparen sie|rabatt|ausverkauf|kostenloser versand)\\\\b', marketplaces: ['amazon_de'], severity: 'block', category: 'pricing_claims', suggestion: 'Preissprache entfernen' },\n  { id: 'pricing_pl', pattern: '\\\\b(najlepsza cena|najtaniej|oszcz\u0119d\u017a|rabat|promocja|wyprzeda\u017c|darmowa wysy\u0142ka)\\\\b', marketplaces: ['amazon_pl', 'allegro'], severity: 'block', category: 'pricing_claims', suggestion: 'Usu\u0144 j\u0119zyk cenowy' },\n  \n  // SUPERLATIVES\n  { id: 'super_en', pattern: '\\\\b(best|#1|number one|top rated|award winning|most popular|leading|ultimate)\\\\b', marketplaces: ['amazon_us', 'amazon_uk', 'ebay'], severity: 'warning', category: 'superlatives', suggestion: 'Use premium or professional-grade', replacement: 'premium' },\n  { id: 'super_de', pattern: '\\\\b(beste|bester|nummer eins|top bewertet|preisgekr\u00f6nt|beliebteste|f\u00fchrend)\\\\b', marketplaces: ['amazon_de'], severity: 'warning', category: 'superlatives', suggestion: 'Verwenden Sie Premium', replacement: 'Premium' },\n  { id: 'super_pl', pattern: '\\\\b(najlepszy|najlepsza|numer jeden|najwy\u017cej oceniany|najpopularniejszy)\\\\b', marketplaces: ['amazon_pl', 'allegro'], severity: 'warning', category: 'superlatives', suggestion: 'U\u017cyj premium', replacement: 'premium' },\n  \n  // MEDICAL\n  { id: 'medical_en', pattern: '\\\\b(cure[sd]?|heal[sd]?|treat[sd]?|prevent[sd]?|therapeutic|antibacterial|antiviral)\\\\b', marketplaces: ['amazon_us', 'amazon_uk', 'ebay'], severity: 'block', category: 'medical_claims', suggestion: 'Use supports, helps with, promotes' },\n  { id: 'medical_de', pattern: '\\\\b(heilt|heilend|behandelt|verhindert|therapeutisch|antibakteriell)\\\\b', marketplaces: ['amazon_de'], severity: 'block', category: 'medical_claims', suggestion: 'Verwenden Sie unterst\u00fctzt, f\u00f6rdert' },\n  { id: 'medical_pl', pattern: '\\\\b(leczy|leczniczy|terapeutyczny|zapobiega|antybakteryjny)\\\\b', marketplaces: ['amazon_pl', 'allegro'], severity: 'block', category: 'medical_claims', suggestion: 'U\u017cyj wspiera, pomaga' },\n  \n  // DISEASES\n  { id: 'diseases', pattern: '\\\\b(cancer|diabetes|alzheimer|depression|anxiety|covid|coronavirus|disease)\\\\b', marketplaces: ['amazon_us', 'amazon_uk', 'amazon_de'], severity: 'block', category: 'medical_diseases', suggestion: 'Disease names prohibited' },\n  \n  // ECO/BIO (EU strict)\n  { id: 'eco_de', pattern: '\\\\b(bio|\u00f6ko|\u00f6kologisch|biologisch|organic)\\\\b', marketplaces: ['amazon_de'], severity: 'block', category: 'eco_certification', suggestion: 'Requires EU cert - use nat\u00fcrlich', replacement: 'nat\u00fcrlich' },\n  { id: 'eco_eu', pattern: '\\\\b(organic|eco-friendly|sustainable)\\\\b', marketplaces: ['amazon_uk', 'amazon_fr', 'amazon_it', 'amazon_es'], severity: 'warning', category: 'eco_certification', suggestion: 'May require EU certification' },\n  \n  // AMAZON TRADEMARK\n  { id: 'amazon_tm', pattern: '\\\\b(amazon\\'?s choice|amazon prime|prime eligible|best seller badge)\\\\b', marketplaces: ['amazon_us', 'amazon_uk', 'amazon_de', 'amazon_pl'], severity: 'block', category: 'amazon_trademark', suggestion: 'Only Amazon can assign badges' },\n  \n  // REVIEWS\n  { id: 'reviews', pattern: '\\\\b(5-?star|five star|highly rated|top reviewed|customer favorite)\\\\b', marketplaces: ['amazon_us', 'amazon_uk'], severity: 'block', category: 'review_manipulation', suggestion: 'Review references prohibited' },\n  \n  // URGENCY\n  { id: 'urgency_en', pattern: '\\\\b(limited stock|while supplies last|selling fast|almost gone|last chance|hurry|act fast)\\\\b', marketplaces: ['amazon_us', 'amazon_uk', 'ebay'], severity: 'block', category: 'urgency', suggestion: 'Urgency language prohibited' },\n  { id: 'urgency_de', pattern: '\\\\b(begrenzter vorrat|solange vorrat reicht|letzte chance|beeilen)\\\\b', marketplaces: ['amazon_de'], severity: 'block', category: 'urgency', suggestion: 'Dringlichkeit verboten' },\n  { id: 'urgency_pl', pattern: '\\\\b(ograniczona ilo\u015b\u0107|do wyczerpania|ostatnia szansa|pospiesz si\u0119)\\\\b', marketplaces: ['amazon_pl', 'allegro'], severity: 'block', category: 'urgency', suggestion: 'Pilno\u015b\u0107 zabroniona' },\n  \n  // COUNTERFEIT\n  { id: 'counterfeit', pattern: '\\\\b(replica|knockoff|imitation|fake|counterfeit|inspired by|dupe)\\\\b', marketplaces: ['all'], severity: 'block', category: 'counterfeit', suggestion: 'Counterfeit language prohibited' },\n  \n  // SAFETY (warning)\n  { id: 'safety', pattern: '\\\\b(safe for children|child-?safe|non-?toxic|bpa-?free|fda approved|clinically proven)\\\\b', marketplaces: ['amazon_us', 'amazon_uk'], severity: 'warning', category: 'safety_claims', suggestion: 'Verify certification exists' },\n  \n  // GUARANTEE\n  { id: 'guarantee', pattern: '\\\\b(100% guaranteed|lifetime guarantee|money-?back|satisfaction guaranteed|risk-?free)\\\\b', marketplaces: ['amazon_us', 'amazon_uk', 'ebay'], severity: 'warning', category: 'guarantee', suggestion: 'Ensure matches your policy' }\n];\n\nfunction validateListing(mp, listing) {\n  const violations = [];\n  const content = [listing.title || '', ...(listing.bullets || []), listing.description || ''].join(' ').toLowerCase();\n  const rules = RULES.filter(r => r.marketplaces.includes('all') || r.marketplaces.includes(mp));\n  \n  for (const rule of rules) {\n    try {\n      const regex = new RegExp(rule.pattern, 'gi');\n      const matches = content.match(regex);\n      if (matches) {\n        let loc = 'content';\n        if ((listing.title || '').toLowerCase().match(regex)) loc = 'title';\n        else if ((listing.bullets || []).some(b => b.toLowerCase().match(regex))) loc = 'bullets';\n        else if ((listing.description || '').toLowerCase().match(regex)) loc = 'description';\n        \n        violations.push({\n          ruleId: rule.id, category: rule.category, severity: rule.severity,\n          matches: [...new Set(matches.map(m => m.toLowerCase()))], location: loc,\n          suggestion: rule.suggestion, replacement: rule.replacement || null,\n          autoFixAvailable: !!rule.replacement\n        });\n      }\n    } catch (e) { /* skip invalid regex */ }\n  }\n  return violations;\n}\n\n// Validate all listings\nconst policyViolations = {};\nlet totalViolations = 0, blockCount = 0, warningCount = 0;\n\nfor (const [mp, listing] of Object.entries(listings)) {\n  const v = validateListing(mp, listing);\n  policyViolations[mp] = v;\n  totalViolations += v.length;\n  blockCount += v.filter(x => x.severity === 'block').length;\n  warningCount += v.filter(x => x.severity === 'warning').length;\n  console.log(`${mp}: ${v.length} violations (${v.filter(x => x.severity === 'block').length} blocks)`);\n}\n\n// Calculate quality score with keyword bonus\nlet qualityScore = 75;\nif (title.length > 50) qualityScore += 5;\nif (description.length > 100) qualityScore += 5;\nif (brand) qualityScore += 5;\nif (hasKeywordFile) { qualityScore += 10; if (keywordStats?.total_uploaded > 20) qualityScore += 5; }\nif (blockCount > 0) qualityScore -= (blockCount * 10); // Penalty for blocks\nqualityScore = Math.max(0, Math.min(100, qualityScore));\n\nconst qualityGrade = qualityScore >= 95 ? 'A+' : qualityScore >= 90 ? 'A' : qualityScore >= 80 ? 'B+' : qualityScore >= 70 ? 'B' : qualityScore >= 50 ? 'C' : 'F';\n\nconst keywordsUsed = hasKeywordFile ? {\n  source: keywordStats?.source || data.keywordSource || 'unknown',\n  total_uploaded: keywordStats?.total_uploaded || data.keywordCount || keywordsArray.length,\n  integrated_in_bullets: true\n} : null;\n\nreturn [{\n  json: {\n    success: blockCount === 0,\n    product_id: 'prod_' + Date.now(),\n    sku: data.sku || 'SKU-001',\n    ai_generation: {\n      quality_score: qualityScore,\n      quality_grade: qualityGrade,\n      expert_enhanced: true,\n      keyword_research_used: hasKeywordFile,\n      translations_applied: data.translationsApplied || false,\n      title_lengths: Object.fromEntries(Object.entries(listings).map(([mp, l]) => [mp, l?.title_length || 0]))\n    },\n    policy_validation: {\n      passed: blockCount === 0,\n      total_violations: totalViolations,\n      blocks: blockCount,\n      warnings: warningCount,\n      violations_by_marketplace: policyViolations\n    },\n    keywords_used: keywordsUsed,\n    marketplaces: marketplaces,\n    listings: listings,\n    keywordData: keywordsArray,\n    generated_at: data.generatedAt || new Date().toISOString()\n  }\n}];"
        }
      },
      {
        "id": "101d08c3-0e7b-42ae-9d5e-175c9e77818d",
        "name": "Error Trigger",
        "type": "n8n-nodes-base.errorTrigger",
        "typeVersion": 1,
        "position": [
          0,
          250
        ],
        "parameters": {}
      },
      {
        "id": "2f62ffa7-55ba-4f96-8d66-d57800c3cece",
        "name": "Store Error to n8n Data",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          200,
          250
        ],
        "parameters": {
          "jsCode": "// Store errors in n8n's built-in static data storage\nconst error = $input.first().json;\n\n// Get persistent storage\nconst staticData = $getWorkflowStaticData('global');\n\n// Initialize error log array if not exists\nif (!staticData.errorLog) {\n  staticData.errorLog = [];\n}\n\n// Create error entry\nconst errorEntry = {\n  id: 'err_' + Date.now(),\n  timestamp: new Date().toISOString(),\n  workflow: 'Multi-Marketplace Generator v2',\n  error_message: error.execution?.error?.message || 'Unknown error',\n  error_node: error.execution?.error?.node?.name || 'Unknown node',\n  error_type: error.execution?.error?.name || 'Error',\n  execution_id: error.execution?.id || 'N/A',\n  execution_mode: error.execution?.mode || 'N/A',\n  input_data: error.execution?.data?.resultData?.runData || null\n};\n\n// Add to log (keep last 50 errors)\nstaticData.errorLog.unshift(errorEntry);\nif (staticData.errorLog.length > 50) {\n  staticData.errorLog = staticData.errorLog.slice(0, 50);\n}\n\n// Update stats\nstaticData.errorStats = staticData.errorStats || { total: 0, lastError: null };\nstaticData.errorStats.total++;\nstaticData.errorStats.lastError = errorEntry.timestamp;\n\nconsole.log('Error stored:', errorEntry.id);\n\nreturn [{ json: { stored: true, error_id: errorEntry.id, total_errors: staticData.errorStats.total } }];"
        }
      },
      {
        "id": "453a60f7-413d-48ab-9984-9143959af207",
        "name": "Webhook Errors",
        "type": "n8n-nodes-base.webhook",
        "typeVersion": 2,
        "position": [
          0,
          450
        ],
        "parameters": {
          "path": "v2/errors",
          "httpMethod": "GET",
          "responseMode": "lastNode",
          "options": {
            "responseCode": 200
          }
        },
        "webhookId": "v2-errors"
      },
      {
        "id": "f1464cd0-d210-46c7-8a09-6c7bc90c9a3b",
        "name": "Get Error Logs",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          200,
          450
        ],
        "parameters": {
          "jsCode": "// Read error logs from n8n static data storage\nconst staticData = $getWorkflowStaticData('global');\n\nconst errorLog = staticData.errorLog || [];\nconst errorStats = staticData.errorStats || { total: 0, lastError: null };\n\n// Get query params for filtering\nconst query = $input.first().json.query || {};\nconst limit = parseInt(query.limit) || 10;\nconst nodeFilter = query.node || null;\n\n// Filter and limit results\nlet filteredLogs = errorLog;\nif (nodeFilter) {\n  filteredLogs = errorLog.filter(e => e.error_node?.toLowerCase().includes(nodeFilter.toLowerCase()));\n}\nfilteredLogs = filteredLogs.slice(0, limit);\n\nreturn [{\n  json: {\n    success: true,\n    stats: {\n      total_errors: errorStats.total,\n      last_error: errorStats.lastError,\n      stored_count: errorLog.length\n    },\n    filters: {\n      limit,\n      node: nodeFilter\n    },\n    errors: filteredLogs\n  }\n}];"
        }
      },
      {
        "id": "ss-keyword-analysis",
        "name": "SS Keyword Analysis",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          1325,
          0
        ],
        "parameters": {
          "jsCode": "// SS Keyword Analysis - Seller Systems Intelligence\n// location: n8n workflow node\n// Purpose: Analyze keywords and generate SS Intelligence data\n// NOT for: Content generation (that's done by Groq nodes)\n\nconst input = $input.first().json;\nconst listings = input.listings || {};\nconst keywordData = input.keywordData || [];\nconst marketplaces = input.marketplaces || [];\n\n// 1. KEYWORD PRIORITY TABLE with Title Density calculation\nconst calculateTitleDensity = (keyword, listings) => {\n  let inTitleCount = 0;\n  let totalMarketplaces = Object.keys(listings).length;\n  \n  for (const [mp, listing] of Object.entries(listings)) {\n    const title = (listing.title || '').toLowerCase();\n    if (title.includes(keyword.toLowerCase())) {\n      inTitleCount++;\n    }\n  }\n  \n  return totalMarketplaces > 0 ? Math.round((inTitleCount / totalMarketplaces) * 100) : 0;\n};\n\nconst keywordPriorityTable = keywordData.map(kw => ({\n  phrase: kw.phrase,\n  searchVolume: kw.searchVolume || 0,\n  rankingJuice: kw.rankingJuice || 0,\n  relevancy: kw.relevancy || 0,\n  priorityScore: kw.priority || (kw.searchVolume * kw.relevancy * 0.01),\n  titleDensity: calculateTitleDensity(kw.phrase, listings),\n  recommendation: kw.searchVolume > 10000 ? 'PRIMARY_TITLE' : \n                 kw.searchVolume > 5000 ? 'SECONDARY_TITLE' : \n                 kw.searchVolume > 2000 ? 'BULLETS' : 'BACKEND'\n})).sort((a, b) => b.priorityScore - a.priorityScore);\n\n// 2. KEYWORD PLACEMENT MAP\nconst analyzeKeywordPlacement = (keyword, listing) => {\n  const kw = keyword.toLowerCase();\n  const placements = [];\n  if ((listing.title || '').toLowerCase().includes(kw)) placements.push('title');\n  (listing.bullets || []).forEach((bullet, idx) => {\n    if (bullet.toLowerCase().includes(kw)) placements.push(`bullet_${idx + 1}`);\n  });\n  if ((listing.description || '').toLowerCase().includes(kw)) placements.push('description');\n  if ((listing.backend_keywords || '').toLowerCase().includes(kw)) placements.push('backend');\n  return placements;\n};\n\nconst keywordPlacementMap = {};\nfor (const [mp, listing] of Object.entries(listings)) {\n  keywordPlacementMap[mp] = {};\n  for (const kw of keywordData) {\n    keywordPlacementMap[mp][kw.phrase] = analyzeKeywordPlacement(kw.phrase, listing);\n  }\n}\n\n// 3. REBUILT LISTING SUGGESTIONS\nconst top3Keywords = keywordPriorityTable.slice(0, 3);\nconst rebuiltSuggestions = {\n  title_optimization: {\n    current_keywords_in_title: top3Keywords.filter(kw => kw.titleDensity > 0).map(kw => kw.phrase),\n    missing_high_priority: top3Keywords.filter(kw => kw.titleDensity === 0).map(kw => kw.phrase),\n    suggested_title_structure: `[Brand] ${top3Keywords[0]?.phrase || ''} - ${top3Keywords[1]?.phrase || ''} | ${top3Keywords[2]?.phrase || ''}`\n  },\n  bullet_optimization: {\n    primary_keyword_bullets: keywordPriorityTable.slice(0, 5).map((kw, idx) => ({\n      bullet_number: idx + 1,\n      target_keyword: kw.phrase,\n      search_volume: kw.searchVolume\n    }))\n  },\n  backend_keywords: {\n    not_in_frontend: keywordData.filter(kw => {\n      const usListing = listings.amazon_us || listings[Object.keys(listings)[0]] || {};\n      const title = (usListing.title || '').toLowerCase();\n      const bullets = (usListing.bullets || []).join(' ').toLowerCase();\n      return !title.includes(kw.phrase.toLowerCase()) && !bullets.includes(kw.phrase.toLowerCase());\n    }).map(kw => kw.phrase).slice(0, 10)\n  }\n};\n\n// 4. STRATEGY RECOMMENDATIONS\nconst totalSearchVolume = keywordData.reduce((sum, kw) => sum + (kw.searchVolume || 0), 0);\nconst avgRankingJuice = keywordData.length > 0 \n  ? keywordData.reduce((sum, kw) => sum + (kw.rankingJuice || 0), 0) / keywordData.length \n  : 0;\n\nconst strategyRecommendations = {\n  market_analysis: {\n    total_search_volume: totalSearchVolume,\n    avg_ranking_juice: Math.round(avgRankingJuice),\n    competition_level: avgRankingJuice > 80000 ? 'HIGH' : avgRankingJuice > 50000 ? 'MEDIUM' : 'LOW',\n    market_opportunity: totalSearchVolume > 50000 ? 'STRONG' : totalSearchVolume > 20000 ? 'MODERATE' : 'NICHE'\n  },\n  ppc_strategy: {\n    phase_1_exact_match: {\n      keywords: top3Keywords.map(kw => kw.phrase),\n      bid_strategy: 'Start high ($1.50-2.00), Top of Search 900% multiplier',\n      goal: 'Establish ranking on primary keywords'\n    },\n    phase_2_expansion: {\n      keywords: keywordPriorityTable.slice(3, 8).map(kw => kw.phrase),\n      bid_strategy: 'Phrase match, moderate bids ($0.80-1.20)',\n      goal: 'Capture long-tail traffic'\n    },\n    phase_3_auto: {\n      strategy: 'Auto campaign catch-all with low bid ($0.10-0.15)',\n      goal: 'Discover new converting keywords'\n    }\n  },\n  organic_strategy: {\n    title_priority: 'Include TOP 2 keywords with highest search volume',\n    bullet_strategy: 'One primary keyword per bullet, CAPS for emphasis',\n    indexing_check: 'Verify indexing with Brand Analytics after 48h',\n    honeymoon_period: 'First 14 days critical - maximize sales velocity'\n  }\n};\n\nconst ssIntelligence = {\n  keyword_priority_table: keywordPriorityTable,\n  keyword_placement_map: keywordPlacementMap,\n  rebuilt_suggestions: rebuiltSuggestions,\n  strategy_recommendations: strategyRecommendations,\n  analysis_timestamp: new Date().toISOString()\n};\n\n// FIXED: Return array of objects with json property (n8n requirement)\nreturn [{ json: { ...input, ss_intelligence: ssIntelligence }}];"
        }
      },
      {
        "id": "ss-knowledge-base",
        "name": "SS Knowledge Base",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          275,
          0
        ],
        "parameters": {
          "jsCode": "// SS Knowledge Base - SellerSystems Inner Circle Expert Knowledge\n// Purpose: Provide structured Amazon listing optimization knowledge to AI prompts\n// Source: Compiled from 194 SellerSystems transcripts (Inner Circle 2022-2025)\n// NOT for: Direct user output - this feeds downstream Groq prompts\n\nconst input = $input.first().json;\n\n// === BULLET POINTS KNOWLEDGE ===\nconst bulletsKnowledge = `SELLERSYSTEMS INNER CIRCLE - BULLET POINT MASTERY:\n\nRANKING JUICE HIERARCHY (CRITICAL - determines indexing power):\n1. TITLE - exact match keywords get MOST ranking credit (position matters: front = more weight)\n2. BULLET POINTS - second most important, top bullets weighted more than bottom\n3. BACKEND KEYWORDS - third level (indexing only, zero direct ranking weight)\n4. DESCRIPTION - lowest weight but still indexes\n5. A+ CONTENT - does NOT index for keywords at all\n\nMANDATORY 5-BULLET STRUCTURE:\nBullet 1: Main USP/differentiator - Why THIS product beats every competitor\nBullet 2: Primary feature converted to customer benefit (feature -> so what -> why care)\nBullet 3: Quality/materials/construction that builds trust and justifies price\nBullet 4: Versatility/use cases that expand perceived value (multiple scenarios)\nBullet 5: Risk reversal/guarantee/customer service promise\n\nBULLET FORMAT RULES:\n- Start with CAPITAL BENEFIT HEADER (2-3 words) followed by dash\n- Format: [CAPS HEADER] - [Feature explanation -> benefit -> how it helps customer]\n- Length: 200-250 characters per bullet (CRITICAL: mobile shows first ~150 chars, front-load benefits!)\n- Each bullet must target a DIFFERENT customer avatar\n- Include secondary keywords NATURALLY (forced keywords hurt conversion)\n- Keywords in BOTH title AND bullets = double ranking credit\n\nPOWER HEADER WORDS: PREMIUM QUALITY, PROFESSIONAL GRADE, VERSATILE DESIGN, DURABLE CONSTRUCTION, EASY TO USE, SATISFACTION GUARANTEED, QUICK SETUP, ALL-IN-ONE\n\nCUSTOMER AVATAR TARGETING (address 3-4 per listing):\n- Eco-Conscious Buyer: sustainability, natural materials, eco-friendly\n- Busy Professional/Parent: efficiency, time-saving, quick setup\n- Budget-Conscious: value for money, durability, long-lasting\n- Gift Shopper: presentation, thoughtfulness, premium packaging\n- Health-Conscious: safety, non-toxic, certifications\n- Minimalist/Design: clean aesthetics, quality over quantity\n- Enthusiast/Hobbyist: technical specs, performance details`;\n\n// === DESCRIPTION KNOWLEDGE ===\nconst descriptionKnowledge = `SELLERSYSTEMS - DESCRIPTION OPTIMIZATION:\n\nDESCRIPTION RANKING WEIGHT: Lowest of all indexable sections, but STILL INDEXES.\nKEY STRATEGY: Include keywords NOT already used in title and bullets to MAXIMIZE root word coverage.\n\nA9 ALGORITHM TARGETING (3 layers):\n1. LEXICAL (exact keywords) - include remaining exact-match phrases\n2. SEMANTIC (BERT model) - use synonyms, related terms, contextual language\n3. BEHAVIORAL (COSMO) - describe use cases that match how customers search\n\nSTRUCTURE: 3 paragraphs:\nParagraph 1: Lifestyle hook - paint picture of customer using product\nParagraph 2: Core value proposition - what makes this product special\nParagraph 3: Trust & close - brand promise, quality assurance\n\nRULES:\n- 150-200 words, 2-3 paragraphs\n- Professional tone, NO hype words, NO emojis\n- Focus on REMAINING keywords (ones NOT in title/bullets)\n- Include complementary use-case keywords and long-tail variations\n- Do NOT repeat keywords already heavily used in title\n- Address customer avatars NOT covered in bullets`;\n\n// === KEYWORD & ROOT WORD KNOWLEDGE ===\nconst keywordKnowledge = `SELLERSYSTEMS - KEYWORD & ROOT WORD STRATEGY:\n\nROOT WORD CONCEPT (FUNDAMENTAL):\n- Root words = base components of keyword phrases\n- Example: \"wireless bluetooth headphones\" roots: wireless, bluetooth, headphones\n- Ranking for ONE keyword gives credit to ALL related root keywords\n- EVERY root word must appear SOMEWHERE in the listing (no holes = no missed rankings)\n\nIMPLEMENTATION PRIORITY:\n1. Title (first 150 chars) = most important roots as EXACT MATCH phrases\n2. Bullets = secondary roots woven naturally into benefit statements\n3. Backend = ALL remaining roots not covered elsewhere\n4. Description = long-tail variations and semantic keywords\n\nTITLE OPTIMIZATION:\n- 200 char max, but PRIORITIZE first 150 chars (highest indexing weight)\n- Structure: [Brand] [Primary Keyword] - [Secondary KW] [Size/Qty] [Key Feature]\n- Put HIGHEST SEARCH VOLUME keyword at front of title\n- Use dashes (-) to separate keyword phrases (helps Amazon parse)\n- Exact match in title > phrase match > broad match for ranking\n\nBACKEND KEYWORDS:\n- 250 bytes limit (NOT characters - special chars = more bytes)\n- Space-separated, NO commas needed\n- NO plurals (Amazon handles singular/plural automatically)\n- NO brand names (yours or competitors - violation risk)\n- Include: misspellings, synonyms, use cases, materials, occasions, Spanish terms\n\nQUALITY CHECKLIST:\n[ ] All root words covered somewhere in listing\n[ ] Main keyword in first 150 chars of title  \n[ ] 5 bullets, each 200-250 chars, CAPS header\n[ ] No keyword repetition across sections (wastes indexing)\n[ ] Mobile-friendly (front-loaded benefits in bullets)\n[ ] Addresses 3+ customer avatars\n[ ] Natural readable language (not keyword-stuffed)`;\n\n// === MARKETPLACE-SPECIFIC RULES ===\nconst marketplaceKnowledge = `MARKETPLACE-SPECIFIC OPTIMIZATION:\n\nAMAZON US: 200 char title, 5 bullets, English, benefits > features, A9 algorithm\nAMAZON DE: German language, 200 char, formal tone, precision/quality valued\nAMAZON PL: Polish REQUIRED, price-sensitive, formal, trust/quality emphasis\nALLEGRO: Polish REQUIRED, max 50 char title, price-conscious, Cassini-like algo, trust badges important\nEBAY: Cassini algorithm (NOT A9), item specifics CRITICAL for ranking, 80 char optimal title, condition important\nETSY: Storytelling approach, 13 tags required, handmade/craft emphasis, warm emotional tone`;\n\nreturn [{\n  json: {\n    ...input,\n    ss_knowledge: {\n      bullets: bulletsKnowledge,\n      description: descriptionKnowledge,\n      keywords: keywordKnowledge,\n      marketplace: marketplaceKnowledge\n    }\n  }\n}];\n"
        }
      }
    ],
    "connections": {
      "Webhook": {
        "main": [
          [
            {
              "node": "Process Input",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Process Input": {
        "main": [
          [
            {
              "node": "SS Knowledge Base",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Groq Generate Bullets": {
        "main": [
          [
            {
              "node": "Groq Generate Description",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Groq Generate Description": {
        "main": [
          [
            {
              "node": "Generate Listings",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Generate Listings": {
        "main": [
          [
            {
              "node": "Groq Translate EU",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Groq Translate EU": {
        "main": [
          [
            {
              "node": "Format Response",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Error Trigger": {
        "main": [
          [
            {
              "node": "Store Error to n8n Data",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Webhook Errors": {
        "main": [
          [
            {
              "node": "Get Error Logs",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Format Response": {
        "main": [
          [
            {
              "node": "SS Keyword Analysis",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "SS Knowledge Base": {
        "main": [
          [
            {
              "node": "Groq Generate Bullets",
              "type": "main",
              "index": 0
            }
          ]
        ]
      }
    },
    "authors": "Shawn Mikrus",
    "name": null,
    "description": null,
    "autosaved": false,
    "workflowPublishHistory": [
      {
        "createdAt": "2026-02-03T18:47:19.890Z",
        "id": 160,
        "workflowId": "DkudCZWTD4TI1FRE",
        "versionId": "9a77613e-48bb-4dd8-9c67-c8a635165b8b",
        "event": "activated",
        "userId": "f0c5c8ed-f6c8-448b-b198-045018831ce5"
      }
    ]
  }
}